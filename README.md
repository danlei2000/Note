	自我介绍：

面试官们好，我叫但磊，本科毕业，在上家公司做的项目，主要是用vue3+ts的技术栈，我上一个做的项目是一个电商平台的后台管理系统，主要是负责品牌管理模块，spu管理和sku管理模块的开发，我做这些模块主要使用element-plus来搭建页面，因为有公共的数据，我就用了跟vue3配套的pinia来管理页面的数据，用axios去封装了一下请求接口等等

##  原型相关

###  请说说你对原型的理解

回答：

​	我觉得所谓的原型就是指两个属性和一个对象，两个属性就是指构造函数上都有一个显式原型属性prototype，构造函数的实例对象都有一个隐式原型属性__proto_ _，它们都指向了那个一个对象，一个对象就是指原型对象，而且这个原型对象上面都会有一个constructor属性指向自己的对应的构造函数

我们使用原型主要就是为了减少内存的占用还有存放一些公共的属性，比如有一个构造函数它的实例化对象都会要用到一个功能相同的方法，要是把这个方法放在构造函数里面，每一次实例化一个对象都要创建一个对象自己的方法，而放在原型上，所有这个构造函数的实例化对象都能访问到这个函数，而且这个函数只在原型上存在一个

在原型上添加方法的时候我们应该尽量在实例化对象之前添加，不然可能会访问不到，原型对象上也可以添加一些属性，实例化对象在访问属性的时候如果自己没有也会顺着原型链向上查找，直到最顶层的Object的原型对象上还找不到就返回undefined，但是在设置属性的时候就不会走原型链，自己有就修改没有就新增一个

我自己之前写项目的时候也会用到原型，像在我的那个电商项目里面，就会用到全局事件总线来实现组件间的通讯，我把它放在原型上，这样就可以方便所有的组件使用

###  什么是构造函数

一个函数在没有被调用之前我们是分不清它是不是构造函数的，只有在用new调用了这个函数，它返回了一个实例对象，那这个函数就是构造函数，像我们平常所说的首字母大写的，它只是一个约定俗成的规范，我们可以不遵守

###  js的内存结构分析

js的内存分为两个部分，栈内存和堆内存，栈内存只能存放地址值，基本数据类型和标识，而堆内存可以存放对象数据类型，基本数据类型，地址值，

在内存中变量和函数名指的是同一种东西统称为标识，在我们写代码的时候两个对象可能会出现嵌套的关系，但在内存结构中他们一定是兄弟关系，实际存放的只是另外一个对象的地址值

###  new做了什么事

new会同步调用构造函数中的代码，同时还会自动声明形参并将实参的数据赋值给形参，还会自动声明this，并向内部存入一个实例对象，将实例对象的(__proto_ _)属性值改为当前构造函数的prototype，最后自动将this作为函数的返回值

##  基本数据流程

###  七大基本数据类型：

number、string、boolean、null、undefined、symbol、bigint

###  需求现在有一个data变量，需要打印出该变量中存储的数据的数据类型

解决方法：

​	1、typeof

​			语法：typeof data

​			返回值类型：string

​			返回值：number	string	boolean	undefined	symbol	bigint						   object	function

​			优点：返回的数据类型很明确

​			缺点：1、会错误的把null判断为object	2、无法区分对象数据类型

​			拓展：对象在内存中，前三位是000存储，typeof以此进行判断，结果null所有位都是000，所以出现误判

​			2、无法区分对象数据类型

​	2、instanceof

​		语法：A	instanceof	B

​		返回值类型：boolean

​		返回值：true||false

​		优点：判断                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            数据类型非常精确，不存在误判的问题

​		缺点：只能告知A是不是B数据类型，无法告知具体哪一类

​	3、使用原型相关

​		可以借调使用对象原型上的toString方法实现

​		```js 

```
Object.prototype.toString.call(data).split(' ')[1].replace(']')
// 或者
{}.toString.call(data).split(' ')[1].replace(']')
// 或者
data.__proto__.constructor.name
```

##  作用域相关

###  前言

在整个编程届，作用域分为两种

​	1、词法作用域(又称为静态作用域)

​		该作用域与函数声明位置有关，与调用无关

​	2、动态作用域

​		该作用域与函数的声明位置无关，与调用位置有关

###  什么是作用域

作用域是变量的查找规则，它会约束变量的使用范围，而这个使用范围就是作用域链，当使用一个变量在当前的作用域没有该变量就会向外层作用域逐层查找，直到全局作用域为止，且变量的查找只能从内向外，不能从外向内

####  作用域的分类

有三种：全局作用域、局部作用域、块级作用域

全局作用域就是最顶层作用域，它可以被任何人访问，局部作用域又称为函数作用域，在函数声明的时候会自动创建一个自己独享的作用域，该作用域只能在该函数内部使用，外界无法访问，块级作用域是ES6新增的一种作用域 ，在使用const或let时会出现块级作用域，

###  预解析规则说明

预解析就是把部分代码提前解析(执行)

预解析分为变量提升和函数提升

变量提升是局部提升，它只会将标识的声明提到最前端，标识的赋值留在原位置

函数提升是整体提升，它将标识提升和赋值提升都提到最前端

预解析只有两种，函数表达式的提升其实就是变量提升

预解析只会将标识声明提升到当前作用域的最顶端

函数提升优于变量提升且重复的标识提升第一次有效后面的都无效

###  形参默认值

如果给函数添加形参默认值的写法，那么形参还是属于当前的函数作用域中，函数内部的代码全部属于块级作用域中(注意：这个块级作用域是临时生成的)，如果函数的形参和函数内部的某个变量名称重名，那么他们会共享初始值，但是后续形参和同名变量是互不影响的



形参其实就是当前函数中的局部变量，形参的本质其实就是变量，他的初始值来源于用户调用函数传入的实参，它存储的值可以发生变化，在函数中声明与形参相同名称的变量是无效的，因为形参本质就是变量，相当于重复声明

##  项目开发流程

客户与产品经理和项目经理对接提出他的需求，在产品经理和项目经理明确需求之后，产品经理出概念图给客户确认需求，需求确认之后会开一次大会，项目经理通过PPT方式展示项目的具体需求和明确各个开发人员需要做的任务，之后我们这些开发人员提出意见，去掉部分无法实现的需求，开完会后产品经理会出一个prd图或原型图给UI设计师，UI设计师出设计图发到蓝湖上我们的项目组，我们通过设计图开发静态页面，后端会发一个swagger的后端接口地址，供我们请求数据，开发期间测试人员会对已经开发的部分进行测试，测出BUG后提交到bug日志系统，我们用的是腾讯的tapd，我们开发人员每天的首要任务就是查看bug日志，自己开发的代码有bug就解决bug，然后继续开发，在前后端都开发完成后，会进行前后端联调，查看项目是否有bug并检查项目能够承受的高并发能力项目联调没有问题就会邀请客户进行测试体验，有问题就处理，没问题，就会给客户交付项目

##  闭包

###  闭包的产生条件

1、必须具有内外函数嵌套	2、内部函数使用外部函数的变量

###  闭包的产生时机

外部函数被调用时，就会产生闭包

###  闭包的优点

延长局部变量生命周期

可以实现js的模块化，防止命名污染，它可以很好的保存数据的安全性，并限制其他人对该数据的操作，实际就是，我们不提供操作数据的方法，外部就没办法修改这个数据

###  闭包的缺点

内存泄漏

​		由于代码书写风格的原因，导致程序浪费更多的内存实现某些功能

内存溢出

​		由于内存泄漏过多，导致内存存满，最终导致程序宕机

###  如何解决闭包的副作用

要及时的释放无用闭包占用的内存

（尽量减少使用闭包）

####  问题：为什么闭包不会销毁？

闭包之所以还能存活，是因为内部函数还存活着，而内部函数需要使用到闭包中缓存的变量，所以导致闭包不会销毁，占用的内存不会释放

解决：将对内部函数的所有引用全部释放掉，就会导致内部函数无人使用，那么内部函数机会被垃圾回收机制回收掉，那么闭包由于没人使用了，闭包也会被垃圾回收机制回收释放

注意： 多个内部函数会共享同一个闭包对象

###  闭包是什么？

闭包是一个对象

​	闭包会缓存内部函数需要使用到的变量，以及它的变量值

​	官方定义：闭包是函数与他周边的词法环境引用的组合

​	简单理解：闭包是函数内部代码与他所在的作用域生成的对象

​	简单来说就是：闭包就是根据函数内部代码以及外部的变量对象组成的一个对象

###  闭包的使用场景

函数的防抖节流，项目中做监听的时候内部函数需要拿新数据做处理

###  栈结构

数据类型：数组

特点：先进后出，后进先出

###  队列结构

数据结构：数组

特点：先进先出，后进后出

执行栈中，存放的是函数的执行上下文

###  执行上下文

执行上下文其实包含了当前函数的this指向，return结果以及一个变量对象

变量对象：他会收集当前函数中，所有的变量以及变量值

​		变量名会成为变量对象的属性名

​		变量值会成为变量对象的属性值

​		扩展：其实函数使用变量，它的查找过程不是向前看这么简单，他会				   先从自己的变量对象上找同名属性，如果没有会找到父级函				   数的变量对象，如果最终找到全局window身上还没有，就会				   报错

​		创建时机

​			每次调用函数的时候，都会创建一个全新的执行上下文，并且自			动放入执行栈中

​		销毁时机

​			函数代码执行结束的时候，就会将对应的执行上下文从执行栈中			弹出，并销毁	这个过程称为出栈

##  垃圾回收机制

###  什么是垃圾回收机制

​	它是浏览器中用来回收内存的一段代码

###  垃圾回收机制的作用

​	用来回收没有人使用的对象

​		如果一个对象没有任何标识或属性存储他的地址值，那么说明当前对象是一个无用的对象，那么垃圾回收机制就会找到这片内存，将其释放

​	__注意：__基本数据类型只存在覆盖的情况，不需要垃圾回收机制

###  垃圾回收机制的核心算法

第一种算法(旧版)：引用计数法

​		js会给创建的每一个对象添加上一个属性[[count]]，初始值为1

​				该对象每被一个标识或属性引用，那么它的count属性就会+1

​				该对象每被一个标识或属性解除引用，那么它的count属性值就会-1

​		最终垃圾回收机制会将count为0的对象进行回收，并将占用的内存进行释放

​		被淘汰的原因(因为有重大BUG)

​			如果多个对象互相循环引用的话，那么即便是把存储他们的变量都清空，但是由于他们各自之间还在相互引用，会导致这些对象的count属性都不为0，最终我们在代码中找不到这些对象，但是他们却一直存在于内存当中了

第二种算法(新版)：标记清除法(Scavenger)

​	该算法一共存在两片区域：新生代区和老生代区

​	简单总结：新版垃圾回收机制会从window对象上开始扫描。读取它身上的所有对象，如果在扫描过程中能见到的对象，就说明是需要保留的，如果扫描结束之后，from数组中还存在的对象，就是需要释放的，

​	新生代区

​		该区域专门用于存放一些刚创建的新对象，新生代区分为from和to两个数组

​		首次准备工作： 

​			浏览器会先扫描一遍window身上所有的属性，如果属性值是一个对象，那么就继续遍历该对象身上所有的属性，如果内部的属性还是对象，继续遍历，以此类推

​			最终将刚才遍历过程中，遇到的所有对象都存入from数组中

​	每隔一段时间都会启动一次垃圾回收机制：

​		1.重新开始扫描window身上所有的属性

​		2.如果遇到了对象，就将其从from数组中移到to数组中去

​		3.如果对象中存有对象，就继续遍历，以此类推

​		4.最终当所有的属性都遍历结束之后，from数组中，还遗留的对象就是需要回收的对象

​		5.垃圾回收机制就会将from数组中，还遗留的对象占用的内存全部释放掉

​		6.将to数组变成from数组，from数组变成to数组

​	算法目的：以空间换时间

老生代区

​	该区域专门用于存放一些存活时间比较久的老对象

​	老生代区只有一个数组

​	问题：一个对象如何变成老生代区的对象

​	一个对象如果在to数组中出现三次，那么他就会成为老生代区的对象

​	流程：

​		1、重新开始扫描window身上所有的属性

​		2、如果发现扫描到的对象，已经存在于老生代区中，就会给其打上一个标记，当所有的属性都遍历结束之后，身上没有标记的对象，就是需要回收的对象

​		3、此时垃圾回收机制，会遍历老生代区的数组，将内部没有标记的对象，全部释放

​		4、等无用的对象都被释放掉之后，会再次遍历老生代区数组，重新整理排列内部对象的排列位置，将多余的内存空间，全部组合到最后去。

​	算法目的：以时间换空间

####  写代码时的注意点

​	尽量不要把东西放在全局中，因为window对象会永久存活，只有等网页关闭才会销毁

##  this指向

###  this

this本身是一个关键字，this的本质就是一个变量(类似于形参)

​	形参->名称由开发者定义，它的值是来源于开发者调用函数的时候传入的实参

​	this->名称是浏览器定义，它的值是来源于浏览器传入的某个数据 (对象)

this里面存的都是对象，这个对象就是当前函数的调用者(也就是谁调用了这个函数)

this的值与函数的声明位置无关，与调用位置无关，与调用方式有关

###  常见this指向

1、普通调用->this是window

例如：fn();

扩展：

​	在严格模式下，普通调用的this会是undefined，在非严格模式下，只要this是undefined，都会被强行改成window

2、隐式调用->this是找到方法的实例对象

​	例如：obj.fn();此时this就是obj

3、构造调用->this是创建出来的全新的实例对象

​	例如：new fn();

4、显式调用->this是强行执行的一个对象

​	例如：call/apply/bind方法都有这种效果

​			fn.call(obj) -> 此时this就是obj

###  特殊的this指向

1、事件回调函数

​	div.onclick=function(){}

​	事件回调函数中的this，会指向事件源对象

​	事件源的意思是，谁绑定了该事件，谁就是事件源

2、定时器

​	setTimeout(function(){},2000)

​	定时器回调函数的this指向window

3.Vue

​	computed,watch,methods,生命周期钩子函数等中，this都会指向当前组件实例对象

4、React

​	类组件

​		class App extends Component {

​			a(){} 这种的this是undefined

​			a=() => {} 这种的this是当前组件实例对象

​		}

​		函数组件

​			this是undefined

5、小程序

​	事件回调函数，生命周期钩子函数中，this是当前页面实例对象(Page的实例对象)

6、箭头函数

​	它是ES6新增的特性

​	它非常的特殊，它的this与声明位置有关，与调用方式无关

​	它没有属于自己的this，每次使用this都会找外层作用域获取(借用)

​	面试题1： 请问箭头函数能否被call/apply/bind，强行改变this指向？

​	回答：不能，因为它没有自己的this，

​				注意：call会执行成功但是没有效果

​	面试题2：请问箭头函数能否被构造调用？

​	回答：不能，因为它没有自己的this，它不是一个构造器

​				注意：此处会直接报错，不是无效

​	面试题3：请问箭头函数是否拥有属于自己的原型对象？

​	回答：没有，因为它没有创建实例对象的能力，所以它不需要原型对象

###  伪数组

什么是伪数组？

1、以下标存储数据

2、具有length属性

3、它不能使用数组的方法

伪数组，数组都是对象

__读取对象指定属性的值的写法__

​	obj.name		obj["name"]

###  手写call函数

fn.call(obj)

​	fn称为被借调函数

​	call称为借调函数

​	obj称为被强行改变的this指向

面试题：请问call方法和apply方法的区别？

回答： 

1.相同点

​	都可以给他们传入第一个实参，用于改变被借调函数的this指向

​	他们都会同步借用被借调函数

​	如果不传入第一个实参(或者undefined||null)，那么被借调的函数的this指向会被强行修改为window

​			扩展：

​				如果传入的是number||string||boolean那么被借调函数的this指向就会变成一个临时创建的对应的包装类对象

​	它们都会将被借调函数的返回值，作为自己的返回值进行return

2、不同点

​	1、接收的实参不同

​		cal方法接收的实参个数为0个到无限个

​				cal方法会将第二个实参开始的所有数据，全部传给被借调函数使用

​		apply方法接收的实参个数为0个到2个

​			apply方法会将第二个参数数组解构之后，全部传给被借调函数使用

总结：call和apply方法，他们的原理几乎相同，只是传参语法有点区别

```js
function fn(x,y,z) {
  console.log(this,x,y)
  return x+y+z
}
var obj= {
  name: "xiaoming",
}

Function.prototype.myCall = function(thatThis,...args) {
  如果thatThis是null或undefined就将this指向改为window
  // if(thiaThis === null || thatThis === undefined)
  if(thatThis == null) {
    thatThis = window;
  }
  如果是基本数据类型就改为临时创建的包装类对象
  if(typeof thatThis === 'number' || typeof thatThis === "string" || thatThis === "boolean") {
    thatThis = new Object(thatThis)
  }
  将需要执行的被借调函数放在指定的thatThis对象上，目的是让后面调用被调用函数的时候this对象是这个thatThis
  thatThis.__proto__.fn = this
  var result = thatThis._fn(...args)
  delete thatThis.__proto__._fn
  return result
}

var result = fn.myCall(2,3,4,56)
```

###  手写bind函数

面试题：请问call方法和bind方法的区别

回答：

​	1、相同点

​		1、都可以给他们传入第一个实参，用于强行改变被借调函数的this指向

​		2、他们接收实参的个数相同，都是0到无限大

​		3、如果没有传入第一个实参或者是undefined||null，那么被借调函数的this指向就会强行变为window，如果传入的是number||string||boolean,那么被借调函数的this就会变成对应的临时包装类对象

​	2、不同点

​		1、被借调函数的执行时机不同

​				call方法会立即调用被借调函数

​				bind方法不会立即调用被借调函数

​		2、返回值不同

​				call方法会将被借调函数的返回值，作为自己的返回值使用

​				bind方法会返回一个被改了this指向的全新函数

​		3、改变this指向的时效性不同

​			call方法只会影响到本轮执行的this指向

​			bind方法会永久修改返回的全新函数的this指向

​			扩展：

​				而且这个所谓的永久，后续无法再次修改它的this指向(包括call/apply/bind)

​		4.传参的次数不同

​			call方法由于是立即调用被借调函数，所以他只有1次传入实参的机会

​			bind方法由于不会立即调用被借调函数，所以他有2次传入实参的机会

​				第一次是在调用bind的时候传入

​				第二次是在调用返回的函数的时候传入

```js
Function.prototype.myBind = function (thatThis,...args) {
  // this->被借调函数(fn) thatThis->想要强行改变的this指向(obj)
  var that = this
  return function(...args2) {
    var result = that.call(thatThis,...args,...args2)
    return result
  }
}
```

###  函数柯里化

他只是一种代码的书写风格

它不是js引擎的内置的东西

将一个本来接收多个参数的函数，切割成多个函数嵌套，每层函数都只接收一个参数

##  异步

异步：将一件事放到未来去做，就是异步，也就是将一段代码延迟一段时间执行

问题：什么是回调函数？

回答：

​	1、我的创建	2、我没调用它	3、但是它执行了

问题：请问回调函数都是异步执行的吗？

回答： 不是，有同步执行的回调函数，而且很多，例如数组相关的方法都是同步回调函数，promise的执行器函数也是同步回调函数



###  异步任务

​	分为宏任务和微任务

​	宏任务是ES5之前就存在的

​	微任务是ES6之后才出现的

用于存储多个宏任务的叫做宏任务队列

用于存储多个微任务的叫做微任务队列

####  常见的宏任务

定时器、请求相关、DOM事件相关

####  常见的微任务

1.Promise的.then方法

2.HTML5新增的mutationObserver

​	简介：它可以监视页面上某个DOM节点的结构变化，如果发生变化，就会执行对应的回调函数

以上这些其实不是宏任务或微任务，他们只是开启宏任务或微任务的手段

异步任务执行时间：延迟到主线程代码执行结束为止

代码执行顺序：首先执行主线程代码->清空微任务队列->执行下一个宏任务

__注意：__微任务队列是清空，宏任务队列是取出一个执行，每次执行完一个宏任务，都会去微任务队列查看一下

面试题：请问js中，是宏任务优先还是微任务优先

回答：如果把主线程代码当做第一个宏任务来看待，那么就是宏任务优先，如果不把主线程代码当做是第一个宏任务，那么就是微任务优先

##  浏览器多线程

js引擎是单线程的，也就是说它同时只能做一件事情

浏览器是一个多进程多线程的软件

​	每个标签页都是一个独立的进程，它的内部具有的线程：

​		1、js线程

​		2、GUI线程

​			GUI线程负责页面的渲染

​		3、使用web Worker创建的新的分线程

__注意：__GUI线程和js线程是互斥的，不能同时工作

首次页面整体流程：首先执行主线程代码->清空微任务对列->GUI线程渲染页面->执行下一个宏任务

更新页面整体流程：清空微任务对列->GUI线程渲染页面->执行下一个宏任务

问题：渲染和挂载是否相同？

回答：他们不是一个东西，但是他们有联系，只要触发了挂载，页面就会发生渲染

挂载->将DOM结构更新到html标签中，渲染->将html标签中的最新结果，绘制到页面上给用户观看

挂载操作是同步的，渲染是异步的

问题：明明已经有了宏任务可以延迟代码的执行，为什么还要推出微任务？

回答：跟页面的更新渲染有关系，假设此时需要修改10w次页面

​	如果在10w个宏任务中，每个宏任务都修改一次页面，页面渲染次数10w次，如果在10w个微任务中，每个微任务都修改一次页面，页面渲染一次

扩展：其实Vue中更新DOM方面，就是放在微任务中实现的

面试题：请问如果在主线程代码中，出现一个100E次的for循环，页面能否立即看到？

回答：js线程和GUI线程是互斥的而且GUI线程渲染页面的实践，是在微任务队列清空之后，所以如果主线程代码被for循环阻塞了10s，页面也会延迟10S渲染

面试题2：请问有没有什么方法，能够加快这里页面的渲染？

回答：

可以使用web worker可以开启额外的线程，将比较费时间的事情，交给这个线程去做那么就可以防止主线程的阻塞，加快页面渲染。

流程：

1、创建worker实例对象，会同时创建一个新的分线程

​		需要提前准备好worker,js文件

​		该文件内部，需要写好onmessage监听

2、将需要执行的代码，一字符串的形式，发送给新创建的分线程执行

​	语法：worker.postMessage(需要执行的代码字符串)

3、由于主线程执行了postMessage方法，所以会触发worker.js文件中的onmessage的回调函数

4、在worker.js文件中的onmessage的回调函数中，我们使用eval函数，将传过来的代码字符串进行执行

5、最终，等分线程执行完所有的代码之后，分线程在使用postMessage，将处理好的数据发回给主线程即可

注意：分线程中执行的代码，不会阻塞主线程代码的执行，所以相当于可以加快主线程代码

##  事件轮询

###  node轮询机制(宏任务部分)

1、node由于没有那么多的分线程帮忙，所以绝大多数事情都要它自己去做，所以node轮询机制一共分为6个阶段，每个阶段都是一个宏任务队列，相当于node将宏任务分成了6种身份，区分了优先级。

2、node事件轮询，起点是1号阶段(timer)，休息区是4号阶段(I/O)，事件轮询一定是从1到6，再回到1，再开始新的循环，在1到6，不会出现跳阶段的可能性

​	想要成功读取文件，需要先开启读取文件的I/O通道。开启通道需要花费100ms



###  node事件轮询机制(微任务)

1、node具有两种微任务

​		.then开启的

​		nextTick开启的

​		本来.then微任务对比宏任务来说，就是VIP，那么nextTick就是SVIP

2、node具有两个微任务队列

​	一个是nextTick专用

​	一个是.then专用

​	如果两个队列都有东西，那么优先执行nextTick队列

__注意：__如果已经身在某个微任务队列中，那就必须清空该微任务队列之后，才能调到其他队列去。

###  浏览器的事件轮询

浏览器中由于具有许多分线程帮忙，所以js引擎负责的事情就相对较少

js线程会将定时器,ajax请求等任务交给对应的管理模块进行管理,满足条件之后,会自动往对应的任务队列中放入回调函数

总结:浏览器的事件轮询机制相对比较简单,因为js线程负责的事情并不多,很多的事情都由对应的管理模块进行控制,这些管理模块都是分线程**

​	**例如:假设我在主线程中,执行setTimeout,那么js线程就会将回调函数和延迟时间,都交给定时器的管理模块,定时器的管理模块会负责倒计时操作,当有满足条件的定时器的时候,会将对应的回调函数放入宏任务队列中**

**浏览器一共具有1个宏任务队列和1个微任务队列**

##  Promise

Promise

​      数据类型:函数(严格来说是构造函数)

​      接收实参

​        个数:1个

​        数据类型:函数(我们称为执行器函数)

​          执行器函数又会接收两个参数

​            resolve

​              调用该函数之后,可以将返回p1对象变成成功状态

​            reject

​              调用该函数之后,可以将返回p1对象变成失败状态

​              同时还会在控制台中,输出报错信息

​        注意:

​          1.该执行器函数的代码会被同步调用



​      返回值

​        一个promise实例对象(简称p1)

​          重要属性:

​            1.state

​              pending->等待(默认值)

​              resolved/fulfilled->成功/完成

​              rejected->失败



​              注意:state值发生变化之后,是不可逆的



​            2.result

​              该值的控制,可以通过给resolve或者reject函数传入实参来控制



​    .then

​      数据类型:函数

​      目的:监视前面promise对象的状态变化,并执行对应的回调函数

​      接收参数

​        个数:0-2个

​        第一个实参是成功回调,如果p1的状态变为成功,就执行该函数

​        第二个实参是失败回调,如果p1的状态变为失败,就执行该函数

​          同时它可以捕获报错,防止控制台报错提示



​      返回值:

​        一定返回一个全新的promise对象(简称p2)

​        如何控制p2的状态?

​          变为成功

​            1.只要回调函数中的代码成功执行结束,那么p2的状态就会变为成功状态

​             严格来说,回调函数return一个非Promise的数据,那么p2就会变为成功

​             

​            2.如果回调函数中返回的是一个成功的Promise对象,那么p2的状态就会变成成功



​          变为失败

​            1.只要回调函数中的代码没能执行结束,那么p2的状态就会变为失败状态

​            2.如果回调函数中返回的是一个失败的Promise对象,那么p2的状态就会变成失败



​        注意:

​          1.无论回调函数中,返回任何内容,p2都一定是一个全新的promise对象

​            如果返回的是一个非Promise的数据,那么这个数据就会成为p2的result值

​            如果返回的是一个Promise对象,那么p2的状态就会参考这个Promise对象的状态



​          2.如果监视的promise状态发生变化,需要执行对应的回调函数

​            结果没有对应的回调函数可以执行,那么当前.then返回的promise的状态会继承上一个promise的状态



​          3..then方法只会在监视的promise状态确定之后,才能开启微任务



​    .catch

​      数据类型:函数

​      目的:它可以监视前面promise对象的状态变化,如果变为失败就执行回调函数

​      接收参数:

​        个数:1个

​        数据类型:函数



​      原理:

​        .catch其实就是.then的语法糖

##  async、await

1.async和await是什么?

​      他们是ES7的新特性语法

​      async和await都是关键字



​      async和await其实是Promise和.then的语法糖



​    2.为什么使用async和await?

​      async和await是回调地狱问题的终极解决方案

​      他们可以实现,让开发者以同步的流程,书写异步的代码

​        方便开发者的代码书写



​    3.怎么使用async和await?



​      async关键字

​        1.async关键字可以单独使用,必须写在函数声明之前

​        2.async函数如果被调用了,那么内部的代码还是会被同步调用

​        3.async函数的返回值:

​          一定是一个全新的promise对象(简称p1)

​          变为成功

​            1.只要async函数中的代码,全部执行结束,那么p1就变为成功

​            2.如果async函数中return一个成功的promise,那么p1就变为成功



​          变为失败

​            1.只要async函数中的代码,出现报错,那么p1就会变为失败

​            2.如果async函数中return一个失败的promise,那么p1就变为失败

​            3.如果await右侧的promise对象变为失败状态,那么p1就变为失败



​      await关键字

​        1.await关键字,不能单独使用,必须写在async函数内部才可以

​          扩展:

​            其实ES12语法之后,已经允许单独使用await了

​            规定了在顶级作用域/每个模块的最外层中,可以单独使用



​            但是目前大多数浏览器,还没有兼容这个标准,

​              所以如果希望在项目中能够这么写,需要使用babel插件编译该语法



​        2.await右侧可以书写Promise对象,如果该对象处于pending状态,

​          就会阻塞后续代码的执行,但是不会拦截右侧代码

​          其实await就相当于是一个.then,他会将函数中后续的代码,都放入成功的回调函数中



​        3.await关键字阻塞代码执行的范围是async函数以内



​        4.await表达式的结果,是右侧Promise对象的result值

​          注意:如果await右侧写的是非Promise的数据,那么await表达式就会把这个数据作为结果返回

##  事件机制

###  什么是事件？

事件就是在程序运行的过程中，发生的事情或者操作

​	例如：在网页运行的时候，用户点击了某个按钮

​	事件组成的三要素：

​		1、事件源

​		2、事件名

​		3、事件处理器(又称为事件回调函数，事件监听)

​		例如，用户做了某些操作，浏览器就会触发对应的事件，然后自动调用对应事件处理器

​	事件机制->多个事件同时触发，那么他们执行顺序规则就是事件机制，事件机制是浏览器提供的

###  事件机制出现过几种

1、事件捕获机制(网景)

2、事件冒泡机制(IE)

3、标准事件机制(又称为标准事件流，目前绝大多数浏览器都使用这个)

###  在标准事件机制中，一共分为几个阶段？

1、捕获阶段

​	从最外层的document开始，向内逐层触发同类型事件，直到最内层的目标元素为止

2、目标阶段

​	触发当前目标元素身上，所有同类型事件

3、冒泡阶段

​	从最内层的目标元素开始，向外层逐层触发同类型事件，直到最外层的document为止

__注意：这三个阶段是一个整体，是一套完整的流程，任何一个地方断开，那么后续事件都不会触发__

###  为什么要有事件机制？

浏览器提供事件机制的目的，是为了方便开发者和用户之间进行交互

​	可以根据用户的操作，实现更多的功能

​	可以监视到用户在该页面的一举一动

###  怎么使用事件/事件机制？

DOM 0写法

​	语法：

​		绑定事件语法：div.onclick = function() {}

​		解绑事件语法“div.onclick = null

​	本质：在给div对象添加onclick属性，并对其进行赋值操作

​	优点：

​		1、绑定事件语法简单

​		2、解绑事件语法简单

​	缺点：

​		1、由于该语法是在给属性进行赋值，导致一个事件只能有一个事件处理器

DOM 2写法：

​	语法：

​		绑定事件语法：div.addEventListener('click',function(){})

​		解绑事件语法：div.removeEventListener('click',function(){})

​	本质：调用div对象身上的addEventListener方法，并传入实参

​	优点：

​		1、由于该语法的本质是在调用函数，而函数是没有调用次数限制的，所以该语法可以给一个事件绑定多个事件处理器

​	缺点：

​		1、绑定事件语法麻烦

​		2、解绑事件语法更麻烦

​			注意：想要解绑事件成功，传入的回调函数必须和绑定时候传入的是同一个

​	第三个实参相关：

​		数据类型：布尔值||对象

​		布尔值：

​			true->将事件绑定在捕获阶段

​			false->将事件绑定在冒泡阶段(默认)

​		对象(扩展)：

​			capture属性

​				true->将事件绑定在捕获阶段

​				false->将事件绑定在冒泡阶段(默认值)

​			passive属性：

​				true->代表事件处理器中，调用event.preventDefault才能有效

​				false->代表事件处理器中，调用event.preventDefault会无效

###  如何阻止冒泡？

标准事件机制：event.stopPropagation()

IE冒泡机制：event.cancelBubble = true

问题：请问如何阻止捕获？

回答：event.stopPropagation()

​	因为事件机制是一体的，所以这一个方法就可以阻止后续阶段的执行

###  在哪里使用用事件机制？

​	事件委托

##  事件委托

###  什么是事件委托(事件委派)?

将当前元素的事件，绑定给父/祖先节点

事件委托不是浏览器自带的东西

事件委托是开发者，在开发代码的过程中，总结出来的一套代码写法

​		他是一种性能优化的代码写法

事件委托的原理就是根据事件冒泡实现的

​        子节点触发了某个事件,会自动冒泡触发父节点的同类型事件

__注意:面试中,如果说到性能优化,一定要说没用之前有什么问题,用了之后得到了什么效果__

###  为什么要使用事件委托？

​	没有使用事件委托之前,存在的问题:

​        1.需要给每个节点,都绑定事件以及事件处理器

​          多个事件处理器会浪费内存

​        2.后续新增的子节点,无法享受到之前绑定的事件

​      使用事件委托写法之后,得到的效果:

​        1.后续新增子节点,也可以享受到之前绑定的事件委托

​        2.减少了内存的消耗,因为此时只要给父/祖先节点绑定即可,从n个变为1个

###  怎么使用事件委托？

流程：

​	1、封装一个bindEvent函数，该函数接受四个实参

​		1、事件源2、事件名3、事件处理器4、目标对象的选择器字符串

​	2、调用bindEvent，并传入需要的参数，就可以给事件源绑定事件，实现事件委托

​	3、如果用户触发了事件源身上的事件，那么在bindEvent函数中，内部会对本次的目标元素，进行身份判断

​	4、如果满足流程1中传入的选择器字符串，那么就使用call方法调用流程1中传入的事件处理器，否则不调用

###  在哪儿使用过事件委托

​	前台项目的三级列表中会使用到

```js
/*
        需求:当用户点击span标签的时候,需要在页面上弹出提示框
    
    */
      function bindEvent2(ele, type, fn, selector) {
        ele.addEventListener(type, function (event) {
          // event.target可以找到目标对象,this就是当前绑定事件的事件源wrap
          const target = event.target;

          if (selector) {
            // matches方法,可以判断前面的DOM元素,是否满足后面传入的选择器的要求
            // 如果满足条件匹配,就返回true,不匹配就返回false
            if (target.matches(selector)) {
              fn.call(target, event);
            }
          } else {
            fn.call(ele, event);
          }
        });
      }
      var spans = document.querySelectorAll("span");
      var wrap = document.querySelector("#wrap");

      //   for (let index = 0; index < spans.length; index++) {
      //     const span = spans[index];
      //     span.onclick=function(){
      //         alert('click span success')
      //     }
      //   }

      //   基础版本事件委托:
      //   wrap.onclick = function () {
      //     alert("click span success");
      //   };

      bindEvent2(
        wrap,
        "click",
        function () {
            console.log(this)
          alert("click span success");
        },
        "span"
      );

      var newSpan = document.createElement("span");
      newSpan.innerText = "E";

      wrap.appendChild(newSpan);
```

##  跨域

###  什么是跨域

违反了浏览器的同源策略

问题：什么是同源？

回答：两个URL的协议名，域名(主机地址)，端口号都相同的话，这两个URL就是同源的

URL的组成部分：协议名+域名(主机地址)+端口号+查询字符串

​	查询字符串由路径和参数组成

​	例如：https://www.baidu.com:443/home?username=xiaoming

扩展：http协议的默认端口是80，https协议的默认端口是443

扩展问题：跨域是否一定会报错？

​	回答：不一定

​		img/video/audio/link/script等标签，跨域请求不报错

​		服务器之间跨域不报错

​		跨域其实是一种操作，该操作并不一定会得到严重的结果

​	问题：什么时候跨域请求会报错？

​	回答：只有在浏览器中，使用ajax发送请求的时候，才会出现跨域报错

###  为什么要有跨域报错？

为了保证用户的数据安全，是一种安全策略

假设跨域请求，不报错，可能出现的问题：

​	前言：真网站称为A网站，假网站称为B网站

​		1、用户请求B网站的服务器，那么对方服务器就会将html文件返回给浏览器

​		2、用户的浏览器会展示B网站的网页

​		3、B网站会使用ajax，携带上A网站的cookie数据，向A网站服务器发送请求

​		4.A网站服务器接收到请求之后,根据cookie数据,确定用户身份,并返回用户重要数据

​      5.B网站成功接收到用户重要数据之后,再使用ajax请求,将数据发回给B网站的服务器

总结：这个过程中，用户的数据丢失了，A网站虽然没有丢失太多的东西，但是信誉受损，最终导致互联网环境变差，大家都不敢上网了

###  怎么解决跨域问题？

1、JSONP

原理：使用了script标签，跨域请求服务器不会报错的效果实现的

流程：

​	1、前端页面中，需要准备好存储数据的变量(data)，还有接收数据的函数(getData)

​	2、当用户点击按钮的时候，创建一个script标签，并给该script标签添加src属性

​		src的属性值是数据服务器的某个接口地址，在地址中使用query将前端的getData函数名传递给服务器

​	3、服务器接收前端传递的函数名称getData，并根据需要返回的数据，拼接成一个全新的字符串

​		例如：“getData(数据)”

​	4、服务器将拼接好的字符串，返回给前端的script标签

​	5、最终，script标签会将返回的文本内容，作为js代码，自行执行

优点：1、上线之后，依旧可以使用

缺点：1、前端需要准备好变量和接收数据的函数，以及script标签

​				后端还要专门写接口去拼接返回的文本内容

​			总结：该方案前后端都要忙，很麻烦

​			2、该方案只能发送GET请求

2、CORS(跨域资源共享)

​        原理:跨域问题是浏览器搞的鬼

​          浏览器怕服务器与用户会有数据损失,所以做了一层检查



​        流程:

​          1.服务器在返回响应的时候,在响应头中,添加配置,来告知浏览器,愿意被当前域名请求即可

​            Access-Control-Allow-Origin: https://www.baidu.com



​        优点:

​          1.前端什么事情都不需要做,很方便

​          2.该方案上线之后也可以使用

3、proxy

​	原理：该方案实现了开发服务器转发请求的功能，解决跨域问题

​	流程：

​		1、在项目启动之前，配置proxy相关规则，告知开发服务器，哪些开头的请求需要转发

​		2、前端页面，请求开发服务器，路径为"/api/getData"

​			由于流程1中，已经通过proxy配置，告知了开发服务器/api开头的请求，都要转发到target地址上

​		3、开发服务器在转发请求给target服务器的时候，会对路径进行重写，将/api去除，可以通过proxy规则的pathRewrite进行控制

​		4、target服务器接收到请求之后，他返回数据给开发服务器

​		5、开发服务器再将请求到的数据返回给前端页面

优点：

​	1、不需要求人，只需要前端少量代码即可

缺点：

​	1、上线之后，无法使用

##  ajax

###  xhr.status

- 2XX：表示成功处理请求
  - 200->代表完美成功，没有任何问题
  - 201->代表本次请求成功，请求参数不对
- 3XX：需要重定向，浏览器直接跳转
  - 302->代表地址重定向，假设用户请求服务器的某个路径，服务器接收到请求之后，控制浏览器重定向到指定地址去
  - 304->代表协商缓存
    - 网络缓存分为两种，一种是协商缓存，一种是强缓存
      - 强缓存就是将本次请求的文件资源缓存在硬盘中，下次还想请求该资源的时候，就不需要再发送请求了，会直接从硬盘中读取上次的文件，不过这个缓存会有一个max-age属性(最大超时时间)
        - 注意：强缓存的状态码为200
      - 协商缓存就是将本次请求的文件资源缓存在硬盘中，下次想要请求该文件的时候，还是会发送请求，将当前缓存文件的最后修改时间(last-modified)和文件唯一标识hash值(e-tag)发送给服务器，服务器对比文件的这两个数据，如果与服务器上的文件相同，那么就返回状态码304，并且不会返回文件
        - 协商缓存的状态码是304
      - 实际开发中，强缓存的使用频率远高于协商缓存
- 4XX：客户端请求错误
  - 403->代表具有该资源，但是拒绝访问
    - 代表具有该资源，但是你的权限不够，不肯给你
    - 这类问题，直接找后端，跟他说账号权限不对
  - 404->代表找不到请求的资源
    - 出现该问题的可能性
      - 你真的写错了地址，跟接口文档对比
      - 可能是proxy规则添加之后，没有重启项目导致的(npm run serve)
- 5XX：服务器端错误
  - 500->代表服务器崩溃，服务器出BUG了，无法处理当前请求
  - 501->代表服务器无法处理当前请求，一般是请求方式不对

###  区别ajax请求与一般HTTP请求

​	ajax->async javascript and xml

注意：

- 对服务器来说，没有任何区别，区别在浏览器端
  - ajax不是一种特殊的请求，他是一种发送请求的技术/工具
    - 我们前端可以使用ajax这个工具，来发送http请求
- 浏览器端发请求，只有XHR或fetch发出
- 浏览器端接收到响应
  - 一般请求，浏览器一般会直接显示响应体数据，也就是我们常说的刷新/跳转页面
  - ajax请求，浏览器不会对界面进行任何更新操作，只是调用监视的回调函数并传入响应相关数据

####  封装一个简易的ajax异步请求函数

```js
function ajax(url) {
  return new Promise((resolve,reject) => {
    // 1、创建一个xhr对象
    const xhr = new XMLHttpRequest()
    // 2、初始化一个异步请求(还没发请求)
    xhr.open('POST',url)
    // 4、监视请求是否响应成功
    xhr.onreadystatechanges = function () {
      // 状态没到4说明请求还没有结束
      if(xhr.readyState !== 4) {
        return
      }
      if(xhr.status >= 200 && xhr.status <= 300) {
        resolve(JSON.parse(xhr.responseText))
      } else {
        reject(new Error('request error status' + request.status))
      }
    }
    // 3、发送请求，并携带请求体参数
    xhr.send({a:1})
    
  })
}
```

##  axios二次封装

###  配置通用的基础路径和超时时间

1、基础路径可以延伸到proxy规则，以及跨域相关内容

​		开发阶段的时候，基础路径baseURL一般写的是开发服务器代理的一个路径，来方便转发给其他服务器，因为浏览器存在跨域的限制，无法直接发http请求，而服务器没有这个限制，所以我们一般是通过开发服务器代替往其他服务器发请求，这里就需要用到proxy去配置代理服务，它会将我们指定的路径的请求，转发到我们想要请求的服务器那里去，所以我们二次封装的时候，基础路径也得写这个指定的路径

2、超过时间可以延伸到请求并发数量问题，以及网络性能优化相关

​	1、小程序最多同时并发10个请求，Chrome和Firefox最多并发6个

​	2、超过时间就是为了防止部分请求占用请求通道时间过长，降低项目性能

​		所以一旦达到了超时时间，那么该请求就会被视为失败，状态码404

###  显示请求进度条

1、显示进度条：请求拦截器回调

2、结束进度条：响应拦截器回调

###  成功的响应回调

成功返回的数据不再是response,而是直接将响应体数据的response.data返回

###  失败的回调

统一处理请求错误，具体请求也可以选择处理或不处理

###  每个请求自动携带userTempId的请求头：在请求拦截器中实现

1、uuid是根据当前电脑生成的一个临时凭证

2、如果用户没有登陆，但是想要将商品加入购物车，那么服务器就会根据uuid，临时创建一个购物车用于存储商品信息

###  如果当前有token，自动携带token的请求头

1、token是根据用户的唯一标识id，生成的一个乱码字符串(相当于是用户的身份证明)

2、如果用户已经登录了， 想要将商品加入购物车，那么服务器就会根据token，解析得到用户的id，然后将商品添加到用户的私人购物车中

3、扩展：如果用户发请求的时候，同时具有uuid和token，那么临时购物车的内容会合并入私人购物车中

###  对token过期的错误进行处理

1、token是否过期一定是后端判断的

2、token其实是根据用户的id+创建时间+特殊的字符串(盐)，再经过加密得到的一个字符串

3、如果服务器判断token已经过期，那么不会返回任何数据，只会返回响应，状态码为401

​			1、与钱有关的，一般5-15分钟换一个新的

​			2、与钱无关的，一般7-15天换一个新的

```js
import axios from 'axios'
import NProgress from 'nprogress'
import 'nprogress/nprogress'
import store from '@/store'
import router from '@/router'
import { v4 as uuidv4 } from 'uuid'

NProgress.configure({ showSpinner: false }) // 隐藏右侧的旋转进度条

// 创建instance
const instance = axios.create({
  baseURL: '/api',
  timeout: 20000
})

// 指定请求拦截器
instance.interceptors.request.use(config => {
  NProgress.start()
  
  const userTempId = uuidv4()
  config.headers.userTempId = userTemId
  
  const userTempId = uuidv4()
  config.headers.userTempId = userTempId
  
  const token = store.state.user.token
  if (token) {
    config.headers.token = token
  }
  
  return config 
})

// 指定响应拦截器
instance.interceptors.response.use(
	response => {
    NProgress.done()
    
    return response.data
  },
  async error => {
    NProgress.done()
    
    const { response } = error
    if(response && response.status) {
      if(response.status === 401) {
        if(router.currentRoute.path!=='/login') {
          await store.dispatch('logout')
          
          router.replace('/login')
          
          message.error('登陆已过期，请重新登陆')
        }
      } else {
        message.error('请求出错：' + error.message || '未知错误')
      }
    } else if{
      message.error('您的网络发生异常，无法连接服务器')
    }
    
    return Promise.reject(error)
  }
)

// 向外暴露instance
export default instance
```

##  Restless API 与 Restful API 

###  Restless API 

- 传统的API，把每个url当作一个功能操作，例如：/deleteUser,/addUser./getUser,
- 同一个url,后台只进行CRUD的某一种操作
- 请求方式不决定请求的CRUD操作
- 一个请求路径只对应一个操作
- 一般只有GET/POST

###  Restful API

- 新式的API，把每个url当作一个唯一资源，/users
- 同一个url，可以通过不同类型的请求对后台资源数据进行CRUD四种操作
- 请求方式来决定了请求在后台进行CRUD的哪种操作
  - GET：查询
  - POST：添加
  - PUT：更新
  - DELETE：删除
- 同一个请求路径可以进行多个操作
- 请求方式会用到GET/POST/PUT/DELETE
- 测试：可以使用json-server快速搭建模拟的rest api接口

## 前端数据存储

###  存储方式

- cookie
- sessionStorage
- localStorage

###  cookie

- 本身用于浏览器和Server通讯
- 被“借用”到本地存储
- 可用document.cookie读取或保存
- 可以利用cookies工具库简化编码

###  cookie的缺点

- 存储大小有限，最大4KB
- http请求时会自动发送给服务器，增加了请求的数据量
- 原生的操作语法不太方便操作cookie
- 浏览器可以设置禁用
- 服务器可以禁止浏览器读取和修改cookie

###  localStorage与sessionStorage

- 相同点：
  - 纯浏览器端存储，大小不受限制，请求时不会自动携带
  - 只能保存文本，如果是对象或数组，需要转换为JSON
  - API相同：
    - setItem(key,value)
    - getItem(key)
    - removeItem(key)
  - 浏览器不能禁用
- 不同点：
  - localStorage保存在本地文件中，除非编码或手动删除，否则一直存在
  - sessionStorage数据保存在当前会话内存中，关闭浏览器则清除

###  区别cookie与localStorage和sessionStorage

以上三者都是浏览器用户存储数据的一部分，都可以成为浏览器的本地存储最早出现的cookie，之后推出HTML5新特性的时候，才有了后续两个内容

1、生命周期

​	cookie：设置了max-age属性，如果没有超过最大存活时间的设置，数据将会一直存活，不设置max-age属性，那么当前cookie就是会话级cookie,存储的数据会在标签页或者浏览器关闭的时候，自动销毁。

​	localStorage(持久化存储)

​		存在它身上的数据，只要不主动删除，就会永久存在

​	sessionStorage(会话级存储)

​		存在他身上的数据，如果关闭当前标签页或者浏览器，存储的数据就会丢失

2、存储位置

​	cookie

​		设置了max-age属性，存储于硬盘中

​		不设置max-age属性，存储于内存中

​	localStorage(持久化存储)

​		存储于硬盘中

​	sessionStorage(会话级存储)

​		存储于内存中

3、存储大小

​	cookie->4KB

​	localStorage -> 一般主流浏览器都是5MB，IE只有3012KB

​	sessionStorage -> 一般主流浏览器都是5MB，IE只有3012KB

4、使用范围

​	cookie

​		它的使用范围受到path和domain属性的控制

​		domain属性

​			假设domain = "www.baidu.com"

​			代表当前这个cookie，可以被当前域名以及他衍生出来的子域名使用

​		path属性

​			假设path = "/a"

​			代表当前这个cookie，可以被当前域名以及他衍生出来的子域名使用

​		总结：儿子可以使用父亲的cookie，父亲不能使用儿子的

​		扩展：HttpOnly属性的作用

​		回答：服务器可以给cookie添加该属性，可以限制前端页面读取使用该cookie

​	localStorage

​		它的使用范围和域名绑定

​			即便是不同的标签页，只要域名相同，也可以共享localStorage的数据

​			多个标签页会共享同一份数据，一边修改，所有页面的都会变化

​	sessionStorage

​		他的使用范围和域名以及标签页绑定

​			该方案无法实现多个标签共享一份数据

​			即便是复制标签页，他们两个的sessionStorage也不是同一份，是两份独立的数据

5、与服务器之间的关系

​	cookie(被借用的本地存储)

​        cookie是服务器创建,浏览器存储的

​        服务器会在响应头中,添加Set-Cookie属性,来将需要存储的cookie数据,发送给前端浏览器

​        浏览器会在请求头中,添加Cookie属性,来将需要发送的cookie数据,发送给后端服务器

​        浏览器会自动存储cookie,还会自动发送cookie

​      localStorage

​        与服务器不熟,没有关系

​      sessionStorage

​        与服务器不熟,没有关系

6、使用场景

​	cookie

​		前端开发这块不常用，主要是给后端人员使用的

​		内部一般会保存一些用户的历史记录，用户个人头像，昵称，token标识等数据

​	localStorage

​        如果有些数据,下次启动项目还想使用,那就选择是用localStorage

​        比如,项目中,实现七天免登陆功能时,会使用到

​          1.我们会将用户第一次登陆的token数据保存在localStorage中

​          2.当用户第二次进行项目的时候,不需要用户再次前往login页面,手动登录

​            我们会使用axios将上次保存的token数据,发送给info接口,兑换用户个人信息

​          3.最终将请求得到的个人信息,展示在页面上

​      sessionStorage

​        sessionStorage相比于localStorage各方面都有差距,但是唯独他是存储于内存中

​          他所有的操作都是内存级别的操作,速度非常快

​            内存和硬盘的操作速度,差距甚至能达到万倍

​        如果有一个数据,是本次项目运行到时候,需要使用到的,那么选择使用sessionStorage

​          例如:将用户本次登录的token保存起来,然后用于发送请求等操作

​        扩展:如果刷新当前页面,存储于sessionStorage中的数据不会丢失,Vuex的会丢失

 ###  面试题:如何实现跨标签页通信?

​    回答:

​      前言:想要发送数据的网页称为A页面,需要接收数据的网页称为B页面

​      1.使用localStorage和storage事件来实现

​        1.在B页面,给window对象,绑定事件storage,并传入回调函数

​          用于监视其余标签页对localStorage的新增和修改

​        2.在A页面,使用localStorage.setItem(key,value),将数据存入到localStorage中

​        3.此时会触发B页面的storage事件的回调函数,执行内部代码,可以通过event对象,

​          获取到当前存储的属性名和新/旧属性值

​        特点:传递数据次数不限,最多一次性传入5MB的数据,使用麻烦程度属于中等,

​          由于localStorage与域名有关,所以只有同一个域名才能互相通信

​      2.使用路径传参

​        1.A页面可以使用window.open方法,跳转一个全新的标签页

​          在跳转的路径中,可以使用query将数据放入URL中

​        2.跳转到B页面的时候,B页面可以通过window.location.search属性,获取到路径中的参数

​        特点:使用麻烦程度属于简单,传递数据次数1次(与跳转次数有关),

​          由于url具有长度限制,所以传递数据量最小,

​          可以跟任何网站实现数据通信

​      3.使用domain属性实现

​        1.在A页面中,使用window.open方法,打开一个全新的网页

​          通过open方法,可以获取到打开B页面的window对象(简称w1)

​        2.在A和B页面中,都执行document.domain="共同的顶级域名"

​        3.在B页面中,给自己的window对象,添加属性和属性值

​        4.在A页面中,就可以通过流程1中,得到的w1对象,获取到B页面存储的数据,

​          也可以对其进行修改

​        特点:使用麻烦程度属于高级,传递数据次数无限,传递数据量最大(与用户电脑内存大小有关),

​          可以与自家公司不同的项目实现数据通信

​      使用场景选择:

​        1.如果是自己项目组的项目开两个标签页,互相通信,

​          就选择使用方案1

​        2.如果是自己公司中多个项目组的项目互相通信.

​          就选择使用方案3

​        3.如果是自己公司与其他公司的项目互相通信,

​          就选择使用方案2



### 从输入url到渲染出页面的整个过程

1. DNS 解析
   1. 域名:
      1. 为了方便使用者记住该网站,相当于降低了推广成本
      2. 域名不仅没有优化性能,反而是劣化性能
   2. DNS解析的目的,就是将域名转换成对应的服务器IP地址

- 浏览器 DNS 缓存
- 计算机 DNS 缓存
- 路由器 DNS 缓存
- 网络运营商 DNS 缓存
- 递归查询

2. TCP 链接：TCP 三次握手  ===> 建立连接

- 客户端发送服务端：我准备好了，请你准备一下
- 服务端发送客户端：我也准备好了，请你确认一下
- 客户端发送服务端：确认完毕

![TCP三次握手_通俗版](C:/Users/但磊/Desktop/精讲gitee/SZ220829_review/01.课件/note/images/TCP三次握手_通俗版.jpeg)

3. 发送请求

- 将请求报文发送过去

4. 返回响应

- 将响应报文发送过来

5. 解析渲染页面

- 遇到 HTML，调用 HTML 解析器，解析成 DOM 树
- 遇到 CSS，调用 CSS 解析器，解析成 CSSOM 树
- 遇到 JS，调用 JS 解析器，解析 JS 代码
  - 可能要修改元素节点，重新调用 HTML 解析器，解析更新DOM 树
  - 可能要修改样式节点，重新调用 CSS 解析器，解析更新 CSSOM 树
- 将 DOM + CSSOM = Render Tree
- **layout 布局(排版)：计算元素的位置和大小信息**
  - **重排:重新排版,如果一个元素的位置,大小发生变化,会导致其余元素也发生变化,就会发生重新排版操作**
- **render 渲染：将颜色/文字/图片等渲染上去**
  -  **重绘:重新绘制,如果元素的颜色,文字等信息,放生变化,不影响到其余元素的布局,就会发生重新绘制操作**
  -  **重排一定会有重绘,重绘不一定会出现重排**
  -  **扩展:**
     - **问题:重绘的范围有多大?**
     - **回答:浏览器的重绘范围是整个图层中所有的元素**
       - **如果有某些元素会频繁变化,就将他单独放置在一个图层中**
       - **可以给这个元素添加will-change属性(css样式),可以让他单独处于一个图层中**
       - **本身就具有图层的元素,canvas,video这些都有**

6. 断开链接：TCP 四次挥手
   (断开请求链接 2 次, 断开响应链接 2 次)

- 客户端发送服务端：请求数据发送完毕，可以断开了
- 服务端发送客户端：请求数据接受完毕，可以断开了
- 服务端发送客户端：响应数据发送完毕，可以断开了
- 客户端发送服务端：响应数据接受完毕，可以断开了

![四次挥手_通俗版](C:/Users/但磊/Desktop/精讲gitee/SZ220829_review/01.课件/note/images/四次挥手_通俗版.jpeg)



##  HTTP1.0和HTTP1.1区别

### 	1.缓存处理

​			HTTP1.1相较于HTTP1.0,引入了更多缓存控制策略

### 	2.带宽优化及网络连接的使用

### 	3.错误通知的管理

​			在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

### 	4.Host头处理

​			在HTTP1.1中,每个请求和响应都必须有HOST属性

### 	5.长连接

​			HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive

​	**扩展:**

​	1.**之前所说的请求并发数,指的就是这个长连接通道,最多可以与一个服务器建立6个通道**

​	2.**通道一般可以保持30s,这个数字可以修改,是服务器控制的**

​	**文章:https://blog.csdn.net/qq_42033567/article/details/107804152**

## HTTP和HTTPS的区别

​	1.HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费

​	2.HTTP协议运行在TCP协议之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的

​	3.HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

​	4.HTTPS可以有效的防止运营商劫持(DNS劫持)，解决了劫持的一个大问题。



## HTTP2.0和HTTP1.1相比的新特性

​	1.新的二进制格式,解析模式从原本的文本解析,变更为二进制解析

​	2.多路复用,一个请求可以请求多个资源

​	3.header压缩,通讯双方都缓存一份header,后续传输即可省略该部分

​	4.服务器推送

##  防抖和节流

###  防抖和节流是什么？

防抖和节流不是浏览器提供的功能，他们是开发者，在开发过程中研究出来的一种特殊的代码写法，他们是一种提高代码性能的代码风格

###  为什么要使用防抖和节流？

问题：没有防抖和节流之前，按钮连续点击多次，触发多次事件，执行多次事件回调函数，

我们经常会在事件中，做发送请求之类的事情，所以我们需要降低请求的发送频率，减少后端服务器的压力

总结：我们使用防抖和节流可以降低一个函数的执行频率



防抖：在一段时间之内，如果想要连续触发多次回调函数，那么最终只有最后一个回调函数会触发，也就是说,想要成功触发第一次回调函数,必须在该函数开启一段时间内,不能在开启第二次

节流:在一段时间之内,如果想要连续触发多次回调函数,那么最终只有第一个回调函数会触发

​        也就是说,想要成功触发第二次回调函数,必须与第一次触发间隔超过规定时间

###  区别:

​        1.函数的执行时机

​          节流->立即执行回调函数

​          防抖->会延迟回调函数的执行时间



​        2.数据时效性不同

​          节流->数据时效性很差,使用的都是旧数据

​          防抖->数据时效性很好,使用的都是最新的数据

###  怎么使用防抖和节流?

​      如以下代码所示



###  在哪使用过防抖和节流?

​      节流的使用场景

​        例如:login页面的登录按钮

​          我们可以限制用户在一段时间之内的触发登录接口的频率



​      防抖的使用场景

​        例如:搜索框的单词联想功能

​          如果用户输入了关键字,我们会使用防抖来获取最新的数据,从而发送请求

​            如果用户连续输入,那么第二次触发就会取消第一次触发

```js
//以下代码是节流代码
    function throttle(callback,delay){
        let startTime = 0;
        return function(){
            // 这个全新的匿名函数,才是真正的事件回调函数
            // console.log(111)

            if(Date.now() - startTime > delay){
                startTime = Date.now();
                callback();
            }
        }
    }

    

    //以下代码是防抖代码
    btn.onclick = debounce(cb,2000)

    function debounce(callback,delay){
        let timer;
        return function(){
            if(timer){
                clearTimeout(timer);
            }
            timer = setTimeout(()=>{
                callback();
            },delay)
        }
    }
```

##  文件上传

###  文件上传整体流程:

​      1.浏览器需要将图片从电脑的硬盘中,读取到当前浏览器的内存中存放

​        使用input[type=file]标签,才可以读取用户的本地文件

​        个人理解,浏览器只提供一种读取文件的方案,是为了保证用户本地数据的安全性

​      2.使用请求,将浏览器内存中的图片,发送给服务器,最终保存在服务器的硬盘中

​        服务器会返回一个图片的网络链接,方便互联网上所有人访问





###  小文件上传流程:

​      1.从页面上,找到input[type=file]标签,给他绑定事件,用于监视用户读取文件操作

​        事件名:change

​      2.从事件回调函数的this.files中,读取到本次用户选中的文件信息

​      3.创建formData对象,并使用append语法,将file对象插入formData中

​      4.将formData对象,作为请求体参数,发送给指定服务器

​      5.将返回的在线链接,传给页面上的某个img标签,作为他的src进行展示

```js
 const file = document.querySelector('#file');

    file.onchange = async function(){
        // File对象其实就是内存中文件的代理对象
        // 他就代表着那个文件,由于文件存储是二进制存储的,所以即便输出给开发者,也看不懂,
        // 所以浏览器专门提取了一些重要信息,给用户观看,这就是File对象
        // console.log(this.files[0])

        const file = this.files[0];

        // FormData函数是浏览器自带的
        const formData = new FormData();

        // 属性名是根据接口文档来写的,本次的属性名是file
        formData.append('file',file);

        const result = await axios.post('http://localhost:3000/upload',formData);

        // console.log(result)

        const img = document.querySelector('#avatar');
        img.src=`http://localhost:3000${result.data}`;
    }
```

 ###  大文件分段上传功能

  函数介绍:

   uploadOne

​    将一个文件传给该函数,就可以实现这个文件的上传功能

​     也就是说想要发送一个文件,就调用一次这个函数

   upload

​    它可以从需要上传的文件中,切割出一部分的内容(2MB),

​    然后通过axios发送给后端

   getHash

​    它可以接收一个文件对象,然后根据文件对象的内容,生成一个唯一的hash值

​    只要文件内容相同,那么生成的hash值也一定相同

  ####  什么是大文件分段上传?

   用户可能在使用项目的过程中,需要上传写大文件,例如视频,音频等

​    但是由于服务器那边最多一次只能接受2MB的数据,所以我们需要将一个文件切成多部分,

​    然后多次发送,最终在服务器端拼装起来

  ####  流程思路:

   1.使用input[type=file]标签,让用户找到需要上传的文件,

​    让浏览器将其从硬盘中,读取到自己的内存中

   2.通过change事件,可以监视到用户读取文件的操作,并在回调函数中,通过this.files伪数组

​    可以获取到当前用户上传的文件,如果是单个文件就是下标0存储的数据

   3.将需要上传的文件,传入uploadOne函数中,实现上传功能

   4.在uploadOne函数中,

​    -调用getHash方法,生成当前文件的唯一hash值

​    -准备filename,将原本的文件名通过.进行切割,在名称中拼接当前时间戳,生成一个全新的文件名

​    -计算出2MB对应多少字节?

​     2*1024*1024

​      1 MB = 1024 KB

​      1 KB = 1024 B

​    -计算出当前一共需要切割成多少份进行发送?

​     通过 文件总大小/2MB的大小可以得知需要切割为多少份

​    -调用upload方法,来发送当前部分文件

​    -在upload方法中,

​     -计算开始/结束下标

​      start = 2MB大小 * 下标

​      end = 2MB大小 * (下标+1)

​       如果本次分享的结尾还没有超过当前文件最大值,那么就发送到本次的结尾

​       如果本次分享的结尾已经超过了当前文件的最大值,那么就发到文件最大值即可

​     -创建formData对象,并将需要发送给服务器的数据,append到该对象中

​      -hash值

​      -data数据

​      -total总份数

​      -index当前是第几份

​      -filename文件名称

​     -使用axios.post方法,将formData对象发送给公司指定服务器

​     -每次发送成功都记录成功的份数,如果文件还没有全部发送结束,就继续递归发送,直到发完为止

 ####  断点续传功能思路:

  1.在发送文件之前,先将当前文件的hash值发送给服务器

  2.那么服务器就会返回这个hash对应的文件上传情况

   -这个文件从来没上传过,返回前端,告知没有上传过,那么我们就将index变量的值设置为0

   -这个文件之前上传过一部分,返回前端,告知该文件上次的进度下标,那么我们就将index变量的值设置为上次进度+1

   -这个文件之前上传结束了,返回前端,告知上传完成

​    这就是秒传功能

```js
 $('#uploaderInput').on('change',function(){
    // console.log(this)
    const file = this.files[0];

    uploadOne(file)

    // for (let index = 0; index < this.files.length; index++) {
    //   const file = this.files[index];
      
    //   uploadOne(file)
    // }
  })

  async function uploadOne(file){
    if(!file)return;

    // 生成当前文件的唯一标识hash值
    // 只要文件内容相同,生成的hash值也一定相同
    // 生成hash值的目的,是为了服务器检查文件是否有缺失
    const hash = await getHash(file);

    const i = file.name.lastIndexOf('.');

    const filename = file.name.slice(0,i) + new Date().getTime() + file.name.slice(i)
    

    // 这是每次需要分享的文件大小
    const shareSize = 2 * 1024 * 1024;

    // 获取当前文件的总大小
    const size = file.size;

    // 计算出当前文件一共需要切割成多少份
    const total = Math.ceil(size/shareSize);

    // 代表已经发送了多少份
    let index = 0;

    // 用于上传一部分的文件
    async function upload(){
      const start = shareSize * index;
      const end = shareSize * (index + 1)>size?size:shareSize * (index + 1);

      // 切割需要的数据,准备发送
      const data = file.slice(start,end);

      const formData = new FormData();

      formData.append('hash',hash);
      formData.append('data',data);
      formData.append('total',total);
      formData.append('index',index);
      formData.append('filename',filename);

      const result = await axios.post('/uploadVideo',formData);

      index++;

      if(index<total){
        // 进入这里说明文件还没有上传结束

        $('#process').text(result.data.process)
        upload();
        // console.log(result)
      }else{
        // 进入这里说明文件已经上传结束
        // console.log('成功了',result)
        $('#videoContent').css('visibility','visible');
        $('#video').attr('src',result.data.videoUrl);
        $('#process').text(result.data.msg)

      }
    }

    upload();
  }

  function getHash(file){
    // 读取文件是一个异步的操作,时间根据文件大小是不一定的
    // 所以我们故意生成一个Promise对象,
    // 如果这个对象状态为成功就说明hash生成了,反之就是还没成功
    return new Promise((resolve)=>{
      // 浏览器自带FileReader函数,可以生成一个文件读取器
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload=function(e){
        // console.log(e.target.result)
        // 将文件的base64字符串,编译出一个唯一的hash值
        const hash = hex_md5(e.target.result);
        // console.log(hash)
        resolve(hash);
      }
    })
  }
```

##  Vue相关

###  需求：将所有组件的配置对象，内部的a属性值全部+1

回答：可以通过Vue的自定义合并策略，来对所有组件的配置对象进行统一的修改操作

```js
Vue.config.optionMergeStrategies.a = function (parent, child, vm) {
  return child + 1
}
```

###  请问，你在项目开发的过程中，是如何捕获到出现的错误的？

​	扩展：错误边界 -> 其实就是如何捕获报错

回答：

​	1、try...catch...

​		好用，但是只能捕获一部分代码的报错

​	2、Promise的catch方法

​		好用，但是只能捕获promise的报错

​	3、生命周期errorCaptured

​		一般，他只能捕获后代组件中出现的报错

​	4、全局配置Vue.config.errorHandler

​		很好用，可以捕获整个项目中出现的报错

###  进阶需求：请问，你在项目上线之后，是如何知道出现了哪些报错的？

回答：

我们可以在项目中，使用以上的四种方法来捕获出现的报错信息，在回调函数中，使用ajax技术，将错误信息全部发送至公司的指定服务器或是接口中，最终项目组，会将BUG汇总到BUG日志平台中，

###  请问项目上线之后，出现了BUG，你会怎么做

回答：

1、如果该BUG与金钱相关，那么立马回退版本，让用户先使用旧版项目，再开始解决维护BUG，等BUG解决之后，再次上线

2、如果该BUG与金钱无关，那么就先解决BUG，再上线就行

##  响应式相关

###  数据驱动：

我们开发者不需要再关注于DOM节点的查找和操作，我们只需要关心数据的变化，只要我们修改了数据，Vue就会自动找到对应的DOM节点进行修改

###  请问什么是响应式属性？什么是非响应式属性？

响应式属性：当开发者修改该属性的值，会导致页面重新渲染，然后显示出最新的结果

非响应式属性：当开发者修改该属性的值，没有导致页面重新渲染，显示的依旧是上次的数据

###  响应式创建时机

1、当组件初始化的时候，data中所有的属性都会被数据劫持，变成响应式属性

**注意：只要是data中存在的属性，会全部变成响应式的**

2、如果给一个响应式属性赋值，而且属性值是一个对象数据类型，那么这个对象中所有的属性，都会经过数据劫持操作，全部变成响应式属性

**注意：赋值的时候，有哪些属性，这些就全是响应式属性，后续新增的都是非响应式属性**

###  如何快速分辨一个属性是否是响应式属性？

直接打印有该属性的对象，如果属性值是(...)，那么说明当前属性是响应式属性

###  如何额外添加响应式属性？

1、Vue.set(target,key/index,value)

2、this.$set(target,key/index,value)

3、Vue.observable(object)

###  删除属性如何具有响应式效果？

1、Vue.delete(target,key/index)

2、this.$delete(target,key/index)



##  nextTick相关

###  请问Vue更新数据是同步更行还是异步更新？

回答：同步更新数据，

​	所以我们可以放心使用数据，每次使用都一定是当前最新

###  请问vue更新DOM是同步更新还是异步更新？

回答：异步更新DOM

###  nextTick是什么？

他是Vue提供的一个函数

###  nectTick的作用

nextTick可以接收一个回调函数

该回调函数，会被延迟到DOM更新之后才会执行

换种说法：在这个回调函数中，可以获取到最新的DOM节点

```js
this.$nextTick(回调函数)
```

###  使用场景

比如说SPU模块的添加属性功能的编辑模式切换可以使用

###  nextTick原理

nextTick内部肯定有异步任务

​	通过代码的观察，可以知道他内部一定是微任务

​	Vue中的nextTick其实用的是.then实现的

###  流程总结：

1、如果开发者调用nextTick

​	那么nextTick会使用callback数组，收集开发者传入的所有的回调函数

2、如果是第一次调用nextTick，就会开启一个nextTick专用的微任务(其实就是.then)

后续调用nextTick不会再开启新的微任务

扩展：也就是说，只有在本次nextTick的回调函数全部执行结束之后，才有可能开启新的微任务

3、在nextTick专用的微任务中，vue会遍历callbacks数组，取出内部所有的回调函数。依次执行

##  mixin混入

全局混入：

```js
Vue.mixin({
  mounted() {
    console.log('全局混入',this.$options.name)
  }
})
```

局部混入：

```js
import moveMixin from '@/mixins/moveMixin'

export default {
  name: 'App',
  mixins:[moveMixin]
}
```

###  需求：在所有组件挂载结束之后，打印他们的name属性值

解决方案：

可以使用混入来解决这个需求

混入分为两种：全局混入，局部混入

全局混入中写的内容，可以注入到每个组件实例上，

局部混入需要在组件的配置对象上添加mixins属性，然后传入局部混合内容，这样该混合的内容，就会只作用于当前这个组件



如果全局/局部混入还有组件都写了同一个生命周期，他们三者的回调函数会共存，执行顺序：全局混入>局部混入>组件内部



如果全局/局部混入还有组件中的data,props,computed,watch,methods等出现冲突，那么优先级：组件内置>局部混入>全局混入

##  请问computed和watch的区别

1、相同点

​	他们都可以监视某个数据的变化，如果数据变化了就执行对应的回调函数

2、不同点

​	使用场景：

​		computed：我需要一个数据，可惜我手头没有，但是我可以根据现有的数据，计算得到

​		例如：购物车的总价/总数等

​		watch：如果有一个数据发生变化之后，我需要做一些事情

​		例如：三级分类列表，如果用户选中了一级分类的某个选项，那么我就会使用这个选项数据请求二级列表

总结：computed更注重于结果，watch更注重于过程

​	computed的返回值是可以显示在页面上的，而watch的返回值没有任何作用



缓存：

computed具有缓存，如果监视的数据没有发生变化，那么computed就会复用上次的结果



属性名的含义不同

​	computed的属性名其实就是计算属性的使用名称

​	watch的属性名其实是代表他想要监视哪个数据