自我介绍：

面试官们好，我叫但磊，本科毕业，在上家公司做的项目，主要是用vue3+ts的技术栈，我上一个做的项目是一个电商平台的后台管理系统，主要是负责品牌管理模块，spu管理和sku管理模块的开发，我做这些模块主要使用element-plus来搭建页面，因为有公共的数据，我就用了跟vue3配套的pinia来管理页面的数据，用axios去封装了一下请求接口等等

##  原型相关

###  请说说你对原型的理解

回答：

​	我觉得所谓的原型就是指两个属性和一个对象，两个属性就是指构造函数上都有一个显式原型属性prototype，构造函数的实例对象都有一个隐式原型属性__proto_ _，它们都指向了那个一个对象，一个对象就是指原型对象，而且这个原型对象上面都会有一个constructor属性指向自己的对应的构造函数

我们使用原型主要就是为了减少内存的占用还有存放一些公共的属性，比如有一个构造函数它的实例化对象都会要用到一个功能相同的方法，要是把这个方法放在构造函数里面，每一次实例化一个对象都要创建一个对象自己的方法，而放在原型上，所有这个构造函数的实例化对象都能访问到这个函数，而且这个函数只在原型上存在一个

在原型上添加方法的时候我们应该尽量在实例化对象之前添加，不然可能会访问不到，原型对象上也可以添加一些属性，实例化对象在访问属性的时候如果自己没有也会顺着原型链向上查找，直到最顶层的Object的原型对象上还找不到就返回undefined，但是在设置属性的时候就不会走原型链，自己有就修改没有就新增一个

我自己之前写项目的时候也会用到原型，像在我的那个电商项目里面，就会用到全局事件总线来实现组件间的通讯，我把它放在原型上，这样就可以方便所有的组件使用

###  什么是构造函数

一个函数在没有被调用之前我们是分不清它是不是构造函数的，只有在用new调用了这个函数，它返回了一个实例对象，那这个函数就是构造函数，像我们平常所说的首字母大写的，它只是一个约定俗成的规范，我们可以不遵守

###  js的内存结构分析

js的内存分为两个部分，栈内存和堆内存，栈内存只能存放地址值，基本数据类型和标识，而堆内存可以存放对象数据类型，基本数据类型，地址值，

在内存中变量和函数名指的是同一种东西统称为标识，在我们写代码的时候两个对象可能会出现嵌套的关系，但在内存结构中他们一定是兄弟关系，实际存放的只是另外一个对象的地址值

###  new做了什么事

new会同步调用构造函数中的代码，同时还会自动声明形参并将实参的数据赋值给形参，还会自动声明this，并向内部存入一个实例对象，将实例对象的(__proto_ _)属性值改为当前构造函数的prototype，最后自动将this作为函数的返回值

##  基本数据流程

###  七大基本数据类型：

number、string、boolean、null、undefined、symbol、bigint

###  需求现在有一个data变量，需要打印出该变量中存储的数据的数据类型

解决方法：

​	1、typeof

​			语法：typeof data

​			返回值类型：string

​			返回值：number	string	boolean	undefined	symbol	bigint						   object	function

​			优点：返回的数据类型很明确

​			缺点：1、会错误的把null判断为object	2、无法区分对象数据类型

​			拓展：对象在内存中，前三位是000存储，typeof以此进行判断，结果null所有位都是000，所以出现误判

​			2、无法区分对象数据类型

​	2、instanceof

​		语法：A	instanceof	B

​		返回值类型：boolean

​		返回值：true||false

​		优点：判断数据类型非常精确，不存在误判的问题

​		缺点：只能告知A是不是B数据类型，无法告知具体哪一类

​	3、使用原型相关

​		可以借调使用对象原型上的toString方法实现

​		```js 

```
Object.prototype.toString.call(data).split(' ')[1].replace(']')
// 或者
{}.toString.call(data).split(' ')[1].replace(']')
// 或者
data.__proto__.constructor.name
```

##  作用域相关

###  前言

在整个编程届，作用域分为两种

​	1、词法作用域(又称为静态作用域)

​		该作用域与函数声明位置有关，与调用无关

​	2、动态作用域

​		该作用域与函数的声明位置无关，与调用位置有关

###  什么是作用域

作用域是变量的查找规则，它会约束变量的使用范围，而这个使用范围就是作用域链，当使用一个变量在当前的作用域没有该变量就会向外层作用域逐层查找，直到全局作用域为止，且变量的查找只能从内向外，不能从外向内

####  作用域的分类

有三种：全局作用域、局部作用域、块级作用域

全局作用域就是最顶层作用域，它可以被任何人访问，局部作用域又称为函数作用域，在函数声明的时候会自动创建一个自己独享的作用域，该作用域只能在该函数内部使用，外界无法访问，块级作用域是ES6新增的一种作用域 ，在使用const或let时会出现块级作用域，

###  预解析规则说明

预解析就是把部分代码提前解析(执行)

预解析分为变量提升和函数提升

变量提升是局部提升，它只会将标识的声明提到最前端，标识的赋值留在原位置

函数提升是整体提升，它将标识提升和赋值提升都提到最前端

预解析只有两种，函数表达式的提升其实就是变量提升

预解析只会将标识声明提升到当前作用域的最顶端

函数提升优于变量提升且重复的标识提升第一次有效后面的都无效

###  形参默认值

如果给函数添加形参默认值的写法，那么形参还是属于当前的函数作用域中，函数内部的代码全部属于块级作用域中(注意：这个块级作用域是临时生成的)，如果函数的形参和函数内部的某个变量名称重名，那么他们会共享初始值，但是后续形参和同名变量是互不影响的



形参其实就是当前函数中的局部变量，形参的本质其实就是变量，他的初始值来源于用户调用函数传入的实参，它存储的值可以发生变化，在函数中声明与形参相同名称的变量是无效的，因为形参本质就是变量，相当于重复声明

##  项目开发流程

客户与产品经理和项目经理对接提出他的需求，在产品经理和项目经理明确需求之后，产品经理出概念图给客户确认需求，需求确认之后会开一次大会，项目经理通过PPT方式展示项目的具体需求和明确各个开发人员需要做的任务，之后我们这些开发人员提出意见，去掉部分无法实现的需求，开完会后产品经理会出一个prd图或原型图给UI设计师，UI设计师出设计图发到蓝湖上我们的项目组，我们通过设计图开发静态页面，后端会发一个swagger的后端接口地址，供我们请求数据，开发期间测试人员会对已经开发的部分进行测试，测出BUG后提交到bug日志系统，我们用的是腾讯的tapd，我们开发人员每天的首要任务就是查看bug日志，自己开发的代码有bug就解决bug，然后继续开发，在前后端都开发完成后，会进行前后端联调，查看项目是否有bug并检查项目能够承受的高并发能力项目联调没有问题就会邀请客户进行测试体验，有问题就处理，没问题，就会给客户交付项目

##  闭包

###  闭包的产生条件

1、必须具有内外函数嵌套	2、内部函数使用外部函数的变量

###  闭包的产生时机

外部函数被调用时，就会产生闭包

###  闭包的优点

延长局部变量生命周期

可以实现js的模块化，防止命名污染，它可以很好的保存数据的安全性，并限制其他人对该数据的操作，实际就是，我们不提供操作数据的方法，外部就没办法修改这个数据

###  闭包的缺点

内存泄漏

​		由于代码书写风格的原因，导致程序浪费更多的内存实现某些功能

内存溢出

​		由于内存泄漏过多，导致内存存满，最终导致程序宕机

###  如何解决闭包的副作用

要及时的释放无用闭包占用的内存

（尽量减少使用闭包）

####  问题：为什么闭包不会销毁？

闭包之所以还能存活，是因为内部函数还存活着，而内部函数需要使用到闭包中缓存的变量，所以导致闭包不会销毁，占用的内存不会释放

解决：将对内部函数的所有引用全部释放掉，就会导致内部函数无人使用，那么内部函数机会被垃圾回收机制回收掉，那么闭包由于没人使用了，闭包也会被垃圾回收机制回收释放

注意： 多个内部函数会共享同一个闭包对象

###  闭包是什么？

闭包是一个对象

​	闭包会缓存内部函数需要使用到的变量，以及它的变量值

​	官方定义：闭包是函数与他周边的词法环境引用的组合

​	简单理解：闭包是函数内部代码与他所在的作用域生成的对象

​	简单来说就是：闭包就是根据函数内部代码以及外部的变量对象组成的一个对象

###  闭包的使用场景

函数的防抖节流，项目中做监听的时候内部函数需要拿新数据做处理

###  栈结构

数据类型：数组

特点：先进后出，后进先出

###  队列结构

数据结构：数组

特点：先进先出，后进后出

执行栈中，存放的是函数的执行上下文

###  执行上下文

执行上下文其实包含了当前函数的this指向，return结果以及一个变量对象

变量对象：他会收集当前函数中，所有的变量以及变量值

​		变量名会成为变量对象的属性名

​		变量值会成为变量对象的属性值

​		扩展：其实函数使用变量，它的查找过程不是向前看这么简单，他会				   先从自己的变量对象上找同名属性，如果没有会找到父级函				   数的变量对象，如果最终找到全局window身上还没有，就会				   报错

​		创建时机

​			每次调用函数的时候，都会创建一个全新的执行上下文，并且自			动放入执行栈中

​		销毁时机

​			函数代码执行结束的时候，就会将对应的执行上下文从执行栈中			弹出，并销毁	这个过程称为出栈

##  垃圾回收机制

###  什么是垃圾回收机制

​	它是浏览器中用来回收内存的一段代码

###  垃圾回收机制的作用

​	用来回收没有人使用的对象

​		如果一个对象没有任何标识或属性存储他的地址值，那么说明当前对象是一个无用的对象，那么垃圾回收机制就会找到这片内存，将其释放

​	__注意：__基本数据类型只存在覆盖的情况，不需要垃圾回收机制

###  垃圾回收机制的核心算法

第一种算法(旧版)：引用计数法

​		js会给创建的每一个对象添加上一个属性[[count]]，初始值为1

​				该对象每被一个标识或属性引用，那么它的count属性就会+1

​				该对象每被一个标识或属性解除引用，那么它的count属性值就会-1

​		最终垃圾回收机制会将count为0的对象进行回收，并将占用的内存进行释放

​		被淘汰的原因(因为有重大BUG)

​			如果多个对象互相循环引用的话，那么即便是把存储他们的变量都清空，但是由于他们各自之间还在相互引用，会导致这些对象的count属性都不为0，最终我们在代码中找不到这些对象，但是他们却一直存在于内存当中了

第二种算法(新版)：标记清除法(Scavenger)

​	该算法一共存在两片区域：新生代区和老生代区

​	简单总结：新版垃圾回收机制会从window对象上开始扫描。读取它身上的所有对象，如果在扫描过程中能见到的对象，就说明是需要保留的，如果扫描结束之后，from数组中还存在的对象，就是需要释放的，

​	新生代区

​		该区域专门用于存放一些刚创建的新对象，新生代区分为from和to两个数组

​		首次准备工作： 

​			浏览器会先扫描一遍window身上所有的属性，如果属性值是一个对象，那么就继续遍历该对象身上所有的属性，如果内部的属性还是对象，继续遍历，以此类推

​			最终将刚才遍历过程中，遇到的所有对象都存入from数组中

​	每隔一段时间都会启动一次垃圾回收机制：

​		1.重新开始扫描window身上所有的属性

​		2.如果遇到了对象，就将其从from数组中移到to数组中去

​		3.如果对象中存有对象，就继续遍历，以此类推

​		4.最终当所有的属性都遍历结束之后，from数组中，还遗留的对象就是需要回收的对象

​		5.垃圾回收机制就会将from数组中，还遗留的对象占用的内存全部释放掉

​		6.将to数组变成from数组，from数组变成to数组

​	算法目的：以空间换时间

老生代区

​	该区域专门用于存放一些存活时间比较久的老对象

​	老生代区只有一个数组

​	问题：一个对象如何变成老生代区的对象

​	一个对象如果在to数组中出现三次，那么他就会成为老生代区的对象

​	流程：

​		1、重新开始扫描window身上所有的属性

​		2、如果发现扫描到的对象，已经存在于老生代区中，就会给其打上一个标记，当所有的属性都遍历结束之后，身上没有标记的对象，就是需要回收的对象

​		3、此时垃圾回收机制，会遍历老生代区的数组，将内部没有标记的对象，全部释放

​		4、等无用的对象都被释放掉之后，会再次遍历老生代区数组，重新整理排列内部对象的排列位置，将多余的内存空间，全部组合到最后去。

​	算法目的：以时间换空间

####  写代码时的注意点

​	尽量不要把东西放在全局中，因为window对象会永久存活，只有等网页关闭才会销毁

##  this指向

###  this

this本身是一个关键字，this的本质就是一个变量(类似于形参)

​	形参->名称由开发者定义，它的值是来源于开发者调用函数的时候传入的实参

​	this->名称是浏览器定义，它的值是来源于浏览器传入的某个数据 (对象)

this里面存的都是对象，这个对象就是当前函数的调用者(也就是谁调用了这个函数)

this的值与函数的声明位置无关，与调用位置无关，与调用方式有关

###  常见this指向

1、普通调用->this是window

例如：fn();

扩展：

​	在严格模式下，普通调用的this会是undefined，在非严格模式下，只要this是undefined，都会被强行改成window

2、隐式调用->this是找到方法的实例对象

​	例如：obj.fn();此时this就是obj

3、构造调用->this是创建出来的全新的事例对象

​	例如：new fn();

4、显式调用->this是强行执行的一个对象

​	例如：call/apply/bind方法都有这种效果

​			fn.call(obj) -> 此时this就是obj

###  特殊的this指向

1、事件回调函数

​	div.onclick=function(){}

​	事件回调函数中的this，会指向事件源对象

​	事件源的意思是，谁绑定了该事件，谁就是事件源

2、定时器

​	setTimeout(function(){},2000)

​	定时器回调函数的this指向window

3.Vue

​	computed,watch,methods,生命周期钩子函数等中，this都会指向当前组件实例对象

4、React

​	类组件

​		class App extends Component {

​			a(){} 这种的this是undefined

​			a=() => {} 这种的this是当前组件实例对象

​		}

​		函数组件

​			this是undefined

5、小程序

​	事件回调函数，生命周期钩子函数中，this是当前页面实例对象(Page的实例对象)

6、箭头函数

​	它是ES6新增的特性

​	它非常的特殊，它的this与声明位置有关，与调用方式无关

​	它没有属于自己的this，每次使用this都会找外层作用域获取(借用)

​	面试题1： 请问箭头函数能否被call/apply/bind，强行改变this指向？

​	回答：不能，因为它没有自己的this，

​				注意：call会执行成功但是没有效果

​	面试题2：请问箭头函数能否被构造调用？

​	回答：不能，因为它没有自己的this，它不是一个构造器

​				注意：此处会直接报错，不是无效

​	面试题3：请问箭头函数是否拥有属于自己的原型对象？

​	回答：没有，因为它没有创建实例对象的能力，所以它不需要原型对象

###  伪数组

什么是伪数组？

1、以下标存储数据

2、具有length属性

3、它不能使用数组的方法

伪数组，数组都是对象

__读取对象指定属性的值的写法__

​	obj.name		obj["name"]

###  手写call函数

fn.call(obj)

​	fn称为被借调函数

​	call称为借调函数

​	obj称为被强行改变的this指向

面试题：请问call方法和apply方法的区别？

回答： 

1.相同点

​	都可以给他们传入第一个实参，用于改变被借调函数的this指向

​	他们都会同步借用被借调函数

​	如果不传入第一个实参(或者undefined||null)，那么被借调的函数的this指向会被强行修改为window

​			扩展：

​				如果传入的是number||string||boolean那么被借调函数的this指向就会变成一个临时创建的对应的包装类对象

​	它们都会将被借调函数的返回值，作为自己的返回值进行return

2、不同点

​	1、接收的实参不同

​		cal方法接收的实参个数为0个到无限个

​				cal方法会将第二个实参开始的所有数据，全部传给被借调函数使用

​		apply方法接收的实参个数为0个到2个

​			apply方法会将第二个参数数组解构之后，全部传给被借调函数使用

总结：call和apply方法，他们的原理几乎相同，只是传参语法有点区别

```js
function fn(x,y,z) {
  console.log(this,x,y)
  return x+y+z
}
var obj= {
  name: "xiaoming",
}

Function.prototype.myCall = function(thatThis,...args) {
  如果thatThis是null或undefined就将this指向改为window
  // if(thiaThis === null || thatThis === undefined)
  if(thatThis == null) {
    thatThis = window;
  }
  如果是基本数据类型就改为临时创建的包装类对象
  if(typeof thatThis === 'number' || typeof thatThis === "string" || thatThis === "boolean") {
    thatThis = new Object(thatThis)
  }
  将需要执行的被借调函数放在指定的thatThis对象上，目的是让后面调用被调用函数的时候this对象是这个thatThis
  thatThis.__proto__.fn = this
  var result = thatThis._fn(...args)
  delete thatThis.__proto__._fn
  return result
}

var result = fn.myCall(2,3,4,56)
```

###  手写bind函数

面试题：请问call方法和bind方法的区别

回答：

​	1、相同点

​		1、都可以给他们传入第一个实参，用于强行改变被借调函数的this指向

​		2、他们接收实参的个数相同，都是0到无限大

​		3、如果没有传入第一个实参或者是undefined||null，那么被借调函数的this指向就会强行变为window，如果传入的是number||string||boolean,那么被借调函数的this就会变成对应的临时包装类对象

​	2、不同点

​		1、被借调函数的执行时机不同

​				call方法会立即调用被借调函数

​				bind方法不会立即调用被借调函数

​		2、返回值不同

​				call方法会将被借调函数的返回值，作为自己的返回值使用

​				bind方法会返回一个被改了this指向的全新函数

​		3、改变this指向的时效性不同

​			call方法只会影响到本轮执行的this指向

​			bind方法会永久修改返回的全新函数的this指向

​			扩展：

​				而且这个所谓的永久，后续无法再次修改它的this指向(包括call/apply/bind)

​		4.传参的次数不同

​			call方法由于是立即调用被借调函数，所以他只有1次传入实参的机会

​			bind方法由于不会立即调用被借调函数，所以他有1次传入实参的机会

​				第一次是在调用bind的时候传入

​				第二次是在调用返回的函数的时候传入

```js
Function.prototype.myBind = function (thatThis,...args) {
  // this->被借调函数(fn) thatThis->想要强行改变的this指向(obj)
  var that = this
  return function(...args2) {
    var result = that.call(thatThis,...args,...args2)
    return result
  }
}
```

###  函数柯里化

他只是一种代码的书写风格

它不是js引擎的内置的东西

将一个本来接收多个参数的函数，切割成多个函数嵌套，每层函数都只接收一个参数

##  异步

异步：将一件事放到未来去做，就是异步，也就是将一段代码延迟一段时间执行

问题：什么是回调函数？

回答：

​	1、我的创建	2、我没调用它	3、但是它执行了

问题：请问回调函数都是异步执行的吗？

回答： 不是，有同步执行的回调函数，而且很多，例如数组相关的方法都是同步回调函数，promise的执行器函数也是同步回调函数



###  异步任务

​	分为宏任务和微任务

​	宏任务是ES5之前就存在的

​	微任务是ES6之后才出现的

用于存储多个宏任务的叫做宏任务队列

用于存储多个微任务的叫做微任务队列

####  常见的宏任务

定时器、请求相关、DOM事件相关

####  常见的微任务

1.Promise的.then方法

2.HTML5新增的mutationObserver

​	简介：它可以监视页面上某个DOM节点的结构变化，如果发生变化，就会执行对应的回调函数

以上这些其实不是宏任务或微任务，他们只是开启宏任务或微任务的手段

异步任务执行时间：延迟到主线程代码执行结束为止

代码执行顺序：首先执行主线程代码->清空微任务队列->执行下一个宏任务

__注意：__微任务队列是清空，宏任务队列是取出一个执行，每次执行完一个宏任务，都会去微任务队列查看一下

面试题：请问js中，是宏任务优先还是微任务优先

回答：如果把主线程代码当做第一个宏任务来看待，那么就是宏任务优先，如果不把主线程代码当做是第一个宏任务，那么就是微任务优先

##  浏览器多线程

js引擎是单线程的，也就是说它同时只能做一件事情

浏览器是一个多进程多线程的软件

​	每个标签页都是一个独立的进程，它的内部具有的线程：

​		1、js线程

​		2、GUI线程

​			GUI线程负责页面的渲染

​		3、使用web Worker创建的新的分线程

__注意：__GUI线程和js线程是互斥的，不能同时工作

首次页面整体流程：首先执行主线程代码->清空微任务对列->GUI线程渲染页面->执行下一个宏任务

更新页面整体流程：清空微任务对列->GUI线程渲染页面->执行下一个宏任务

问题：渲染和挂载是否相同？

回答：他们不是一个东西，但是他们有联系，只要触发了挂载，页面就会发生渲染

挂载->将DOM结构更新到html标签中，渲染->将html标签中的最新结果，绘制到页面上给用户观看

挂载操作是同步的，渲染是异步的

问题：明明已经有了宏任务可以延迟代码的执行，为什么还要推出微任务？

回答：跟页面的更新渲染有关系，假设此时需要修改10w次页面

​	如果在10w个宏任务中，每个宏任务都修改一次页面，页面渲染次数10w次，如果在10w个微任务中，每个微任务都修改一次页面，页面渲染一次

扩展：其实Vue中更新DOM方面，就是放在微任务中实现的

面试题：请问如果在主线程代码中，出现一个100E次的for循环，页面能否立即看到？

回答：js线程和GUI线程是互斥的而且GUI线程渲染页面的实践，是在微任务队列清空之后，所以如果主线程代码被for循环阻塞了10s，页面也会延迟10S渲染

面试题2：请问有没有什么方法，能够加快这里页面的渲染？

回答：

可以使用web worker可以开启额外的线程，将比较费时间的事情，交给这个线程去做那么就可以防止主线程的阻塞，加快页面渲染。

流程：

1、创建worker实例对象，会同时创建一个新的分线程

​		需要提前准备好worker,js文件

​		该文件内部，需要写好onmessage监听

2、将需要执行的代码，一字符串的形式，发送给新创建的分线程执行

​	语法：worker.postMessage(需要执行的代码字符串)

3、由于主线程执行了postMessage方法，所以会触发worker.js文件中的onmessage的回调函数

4、在worker.js文件中的onmessage的回调函数中，我们使用eval函数，将传过来的代码字符串进行执行

5、最终，等分线程执行完所有的代码之后，分线程在使用postMessage，将处理好的数据发回给主线程即可

注意：分线程中执行的代码，不会阻塞主线程代码的执行，所以相当于可以加快主线程代码