自我介绍：

面试官们好，我叫但磊，本科毕业，在上家公司做的项目，主要是用vue3+ts的技术栈，我上一个做的项目是一个电商平台的后台管理系统，主要是负责品牌管理模块，spu管理和sku管理模块的开发，我做这些模块主要使用element-plus来搭建页面，因为有公共的数据，我就用了跟vue3配套的pinia来管理页面的数据，用axios去封装了一下请求接口等等

##  原型相关

###  请说说你对原型的理解

回答：

​	我觉得所谓的原型就是指两个属性和一个对象，两个属性就是指构造函数上都有一个显式原型属性prototype，构造函数的实例对象都有一个隐式原型属性__proto_ _，它们都指向了那个一个对象，一个对象就是指原型对象，而且这个原型对象上面都会有一个constructor属性指向自己的对应的构造函数

我们使用原型主要就是为了减少内存的占用还有存放一些公共的属性，比如有一个构造函数它的实例化对象都会要用到一个功能相同的方法，要是把这个方法放在构造函数里面，每一次实例化一个对象都要创建一个对象自己的方法，而放在原型上，所有这个构造函数的实例化对象都能访问到这个函数，而且这个函数只在原型上存在一个

在原型上添加方法的时候我们应该尽量在实例化对象之前添加，不然可能会访问不到，原型对象上也可以添加一些属性，实例化对象在访问属性的时候如果自己没有也会顺着原型链向上查找，直到最顶层的Object的原型对象上还找不到就返回undefined，但是在设置属性的时候就不会走原型链，自己有就修改没有就新增一个

我自己之前写项目的时候也会用到原型，像在我的那个电商项目里面，就会用到全局事件总线来实现组件间的通讯，我把它放在原型上，这样就可以方便所有的组件使用

###  什么是构造函数

一个函数在没有被调用之前我们是分不清它是不是构造函数的，只有在用new调用了这个函数，它返回了一个实例对象，那这个函数就是构造函数，像我们平常所说的首字母大写的，它只是一个约定俗成的规范，我们可以不遵守

###  js的内存结构分析

js的内存分为两个部分，栈内存和堆内存，栈内存只能存放地址值，基本数据类型和标识，而堆内存可以存放对象数据类型，基本数据类型，地址值，

在内存中变量和函数名指的是同一种东西统称为标识，在我们写代码的时候两个对象可能会出现嵌套的关系，但在内存结构中他们一定是兄弟关系，实际存放的只是另外一个对象的地址值

###  new做了什么事

new会同步调用构造函数中的代码，同时还会自动声明形参并将实参的数据赋值给形参，还会自动声明this，并向内部存入一个实例对象，将实例对象的(__proto_ _)属性值改为当前构造函数的prototype，最后自动将this作为函数的返回值

##  基本数据流程

###  七大基本数据类型：

number、string、boolean、null、undefined、symbol、bigint

###  需求现在有一个data变量，需要打印出该变量中存储的数据的数据类型

解决方法：

​	1、typeof

​			语法：typeof data

​			返回值类型：string

​			返回值：number	string	boolean	undefined	symbol	bigint						   object	function

​			优点：返回的数据类型很明确

​			缺点：1、会错误的把null判断为object	2、无法区分对象数据类型

​			拓展：对象在内存中，前三位是000存储，typeof以此进行判断，结果null所有位都是000，所以出现误判

​			2、无法区分对象数据类型

​	2、instanceof

​		语法：A	instanceof	B

​		返回值类型：boolean

​		返回值：true||false

​		优点：判断数据类型非常精确，不存在误判的问题

​		缺点：只能告知A是不是B数据类型，无法告知具体哪一类

​	3、使用原型相关

​		可以借调使用对象原型上的toString方法实现

​		```js 

```
Object.prototype.toString.call(data).split(' ')[1].replace(']')
// 或者
{}.toString.call(data).split(' ')[1].replace(']')
// 或者
data.__proto__.constructor.name
```

##  作用域相关

###  前言

在整个编程届，作用域分为两种

​	1、词法作用域(又称为静态作用域)

​		该作用域与函数声明位置有关，与调用无关

​	2、动态作用域

​		该作用域与函数的声明位置无关，与调用位置有关

###  什么是作用域

作用域是变量的查找规则，它会约束变量的使用范围，而这个使用范围就是作用域链，当使用一个变量在当前的作用域没有该变量就会向外层作用逐层查找，直到全局作用域为止，且变量的查找只能从内向外，不能从外向内

####  作用域的分类

有三种：全局作用域、局部作用域、块级作用域

全局作用域就是最顶层作用域，它可以被任何人访问，局部作用域又称为函数作用域，在函数声明的时候会自动创建一个自己独享的作用域，该作用域只能在该函数内部使用，外界无法访问，块级作用域是ES6新增的一种作用域 ，在使用const或let时会出现块级作用域，

###  预解析规则说明

预解析就是把部分代码提前解析(执行)

预解析分为变量提升和函数提升

变量提升是局部提升，它只会将标识的声明提到最前端，标识的赋值留在原位置

函数提升是整体提升，它将标识提升和赋值提升都提到最前端

预解析只有两种，函数表达式的提升其实就是变量提升

预解析只会将标识声明提升到当前作用域的最顶端

函数提升优于变量提升且重复的标识提升第一次有效后面的都无效

###  形参默认值

如果给函数添加形参默认值的写法，那么形参还是属于当前的函数作用域中，函数内部的代码全部属于块级作用域中(注意：这个块级作用域是临时生成的)，如果函数的形参和函数内部的某个变量名称重名，那么他们会共享初始值，但是后续形参和同名变量是互不影响的



形参其实就是当前函数中的局部变量，形参的本质其实就是变量，他的初始值来源于用户调用函数传入的实参，它存储的值可以发生变化，在函数中声明与形参相同名称的变量是无效的，因为形参本质就是变量，相当于重复声明

##  项目开发流程

客户与产品经理和项目经理对接提出他的需求，在产品经理和项目经理明确需求之后，产品经理出概念图给客户确认需求，需求确认之后会开一次大会，项目经理通过PPT方式展示项目的具体需求和明确各个开发人员需要做的任务，之后我们这些开发人员提出意见，去掉部分无法实现的需求，开完会后产品经理会出一个prd图或原型图给UI设计师，UI设计师出设计图发到蓝湖上我们的项目组，我们通过设计图开发静态页面，后端会发一个swagger的后端接口地址，供我们请求数据，开发期间测试人员会对已经开发的部分进行测试，测出BUG后提交到bug日志系统，我们用的是腾讯的tapd，我们开发人员每天的首要任务就是查看bug日志，自己开发的代码有bug就解决bug，然后继续开发，在前后端都开发完成后，会进行前后端联调，查看项目是否有bug并检查项目能够承受的高并发能力项目联调没有问题就会邀请客户进行测试体验，有问题就处理，没问题，就会给客户交付项目

##  闭包

###  闭包的产生条件

1、必须具有内外函数嵌套	2、内部函数使用外部函数的变量

###  闭包的产生时机

外部函数被调用时，就会产生闭包

###  闭包的优点

延长局部变量生命周期

可以实现js的模块化，防止命名污染，它可以很好的保存数据的安全性，并限制其他人对该数据的操作，实际就是，我们不提供操作数据的方法，外部就没办法修改这个数据

###  闭包的缺点

内存泄漏

​		由于代码书写风格的原因，导致程序浪费更多的内存实现某些功能

内存溢出

​		由于内存泄漏过多，导致内存存满，最终导致程序宕机

###  如何解决闭包的副作用

要及时的释放无用闭包占用的内存

（尽量减少使用闭包）

####  问题：为什么闭包不会销毁？

闭包之所以还能存活，是因为内部函数还存活着，而内部函数需要使用到闭包中缓存的变量，所以导致闭包不会销毁，占用的内存不会释放

解决：将对内部函数的所有引用全部释放掉，就会导致内部函数无人使用，那么内部函数机会被垃圾回收机制回收掉，那么闭包由于没人使用了，闭包也会被垃圾回收机制回收释放

注意： 多个内部函数会共享同一个闭包对象

###  闭包是什么？

闭包是一个对象

​	闭包会缓存内部函数需要使用到的变量，以及它的变量值

​	官方定义：闭包是函数与他周边的词法环境引用的组合

​	简单理解：闭包是函数内部代码与他所在的作用域生成的对象

​	简单来说就是：闭包就是根据函数内部代码以及外部的变量对象组成的			一个对象

###  闭包的使用场景

函数的防抖节流

###  栈结构

数据类型：数组

特点：先进后出，后进先出

###  队列结构

数据结构：数组

特点：先进先出，后进后出

执行栈中，存放的是函数的执行上下文

###  执行上下文

执行上下文其实包含了当前函数的this指向，return结果以及一个变量对象

变量对象：他会收集当前函数中，所有的变量以及变量值

​		变量名会成为变量对象的属性名

​		变量值会成为变量对象的属性值

​		扩展：其实函数使用变量，它的查找过程不是向前看这么简单，他会				   先从自己的变量对象上找同名属性，如果没有会找到父级函				   数的变量对象，如果最终找到全局window身上还没有，就会				   报错

​		创建时机

​			每次调用函数的时候，都会创建一个全新的执行上下文，并且自			动放入执行栈中

​		销毁时机

​			函数代码执行结束的时候，就会将对应的执行上下文从执行栈中			弹出，并销毁	这个过程称为出栈

##  垃圾回收机制

###  什么是垃圾回收机制

​	它是浏览器中用来回收内存的一段代码

###  垃圾回收机制的作用

​	用来回收没有人使用的对象

​		如果一个对象没有任何标识或属性存储他的地址值，那么说明当前对象是一个无用的对象，那么垃圾回收机制就会找到这片内存，将其释放

​	__注意：__基本数据类型只存在覆盖的情况，不需要垃圾回收机制

###  垃圾回收机制的核心算法

第一种算法(旧版)：引用计数法

​		js会给创建的每一个对象添加上一个属性[[count]]，初始值为1

​				该对象每被一个标识或属性引用，那么它的count属性就会+1

​				该对象每被一个标识或属性解除引用，那么它的count属性值就会-1

​		最终垃圾回收机制会将count为0的对象进行回收，并将占用的内存进行释放

​		被淘汰的原因(因为有重大BUG)

​			如果多个对象互相循环引用的话，那么即便是把存储他们的变量都清空，但是由于他们各自之间还在相互引用，会导致这些对象的count属性都不为0，最终我们在代码中找不到这些对象，但是他们却一直存在于内存当中了

第二种算法(新版)：标记清除法(Scavenger)

​	该算法一共存在两片区域：新生代区和老生代区

​	简单总结：新版垃圾回收机制会从window对象上开始扫描。读取它身上的所有对象，如果在扫描过程中能见到的对象，就说明是需要保留的，如果扫描结束之后，from数组中还存在的对象，就是需要释放的，

​	新生代区

​		该区域专门用于存放一些刚创建的新对象，新生代区分为from和to两个数组

​		首次准备工作： 

​			浏览器会先扫描一遍window身上所有的属性，如果属性值是一个对象，那么就继续遍历该对象身上所有的属性，如果内部的属性还是对象，继续遍历，以此类推

​			最终将刚才遍历过程中，遇到的所有对象都存入from数组中

​	每隔一段时间都会启动一次垃圾回收机制：

​		1.重新开始扫描window身上所有的属性

​		2.如果遇到了对象，就将其从from数组中移到to数组中去

​		3.如果对象中存有对象，就继续遍历，以此类推

​		4.最终当所有的属性都遍历结束之后，from数组中，还遗留的对象就是需要回收的对象

​		5.垃圾回收机制就会将from数组中，还遗留的对象占用的内存全部释放掉

​		6.将to数组变成from数组，from数组变成to数组

​	算法目的：以空间换时间

老生代区

​	该区域专门用于存放一些存活时间比较久的老对象

​	老生代区只有一个数组

​	问题：一个对象如何变成老生代区的对象

​	一个对象如果在to数组中出现三次，那么他就会成为老生代区的对象

​	流程：

​		1、重新开始扫描window身上所有的属性

​		2、如果发现扫描到的对象，已经存在于老生代区中，就会给其打上一个标记，当所有的属性都遍历结束之后，身上没有标记的对象，就是需要回收的对象

​		3、此时垃圾回收机制，会遍历老生代区的数组，将内部没有标记的对象，全部释放

​		4、等无用的对象都被释放掉之后，会再次遍历老生代区数组，重新整理排列内部对象的排列位置，将多余的内存空间，全部组合到最后去。

​	算法目的：以时间换空间

####  写代码时的注意点

​	尽量不要把东西放在全局中，因为window对象会永久存活，只有等网页关闭才会销毁



